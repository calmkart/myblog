<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="传统的负载均衡策略一般是: 客户端 -dns -4层库在均衡(HA) -7层负载均衡 -具体的后端服务 这种方式处理服务发现和动态配置比较难搞,比如后端服务动态扩缩容什么的。 一开始的做法肯定是OP人工维护7层负载均衡集群配置..."><title>kubernetes集群中服务的负载均衡和外部发现</title><link rel=canonical href=https://www.calmkart.com/posts/2019/05/2019-05-25-kubernetes%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E5%A4%96%E9%83%A8%E5%8F%91%E7%8E%B0/><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap"><link rel=stylesheet href=/scss/style.min.d938302c9c68b5f1fda0a78ef59a80f98a22f71eeffb56a5408c148f22d8c7d5.css><meta property='og:title' content="kubernetes集群中服务的负载均衡和外部发现"><meta property='og:description' content="传统的负载均衡策略一般是: 客户端 -dns -4层库在均衡(HA) -7层负载均衡 -具体的后端服务 这种方式处理服务发现和动态配置比较难搞,比如后端服务动态扩缩容什么的。 一开始的做法肯定是OP人工维护7层负载均衡集群配置..."><meta property='og:url' content='https://www.calmkart.com/posts/2019/05/2019-05-25-kubernetes%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E5%A4%96%E9%83%A8%E5%8F%91%E7%8E%B0/'><meta property='og:site_name' content='cAlm的个人Blog'><meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:tag' content='dns'><meta property='article:tag' content='externalip'><meta property='article:tag' content='ingress'><meta property='article:tag' content='kubernetes'><meta property='article:tag' content='nginx'><meta property='article:tag' content='服务发现'><meta property='article:tag' content='负载均衡'><meta property='article:published_time' content='2019-05-25T00:00:00+00:00'><meta property='article:modified_time' content='2019-05-25T00:00:00+00:00'><meta name=twitter:title content="kubernetes集群中服务的负载均衡和外部发现"><meta name=twitter:description content="传统的负载均衡策略一般是: 客户端 -dns -4层库在均衡(HA) -7层负载均衡 -具体的后端服务 这种方式处理服务发现和动态配置比较难搞,比如后端服务动态扩缩容什么的。 一开始的做法肯定是OP人工维护7层负载均衡集群配置..."></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><div class=site-meta><h1 class=site-name><a href=/>cAlm的个人Blog</a></h1><h2 class=site-description>随手记录些东西</h2></div></header><ol class=menu id=main-menu><li><a href=/><span>首页</span></a></li><li><a href=/archives><span>归档</span></a></li><li><a href=/categories><span>分类</span></a></li><li><a href=/search><span>搜索</span></a></li><li><a href=/about><span>关于</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/ style=background-color:#bed8ef;color:#0f283d>计算机</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/posts/2019/05/2019-05-25-kubernetes%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E5%A4%96%E9%83%A8%E5%8F%91%E7%8E%B0/>kubernetes集群中服务的负载均衡和外部发现</a></h2><h3 class=article-subtitle>传统的负载均衡策略一般是: 客户端 -dns -4层库在均衡(HA) -7层负载均衡 -具体的后端服务 这种方式处理服务发现和动态配置比较难搞,比如后端服务动态扩缩容什么的。 一开始的做法肯定是OP人工维护7层负载均衡集群配置...</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2019-05-25T00:00:00Z>2019年5月25日星期六</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 5 分钟</time></div></footer></div></header><section class=article-content><p>传统的负载均衡策略一般是:</p><p><strong>客户端 -> dns -> 4层库在均衡(HA) -> 7层负载均衡 -> 具体的后端服务</strong></p><p>这种方式处理服务发现和动态配置比较难搞,比如后端服务动态扩缩容什么的。 一开始的做法肯定是OP人工维护7层负载均衡集群配置，以nginx为例，用git仓库之类的做人工服务发现和变更。这样很显然是不科学的。然后就会开始希望用种种自动化的手段去处理服务发现，比如微博的nginx-upsync-module,比如nginx-lua，比如openresty，比如etcd+confd等种种手段实现服务发现和自动化配置，但还是有很多瑕疵，比如etcd+confd每次修改upstream的服务后端就要reload nginx，nginx的策略会新开x个worker，容易造成性能问题甚至机器顶不住。而且vm服务机器的逻辑和upstream挂钩也有问题，总之，麻烦的很。</p><p>而kubernetes处理这一套服务发现和负载均衡的方法就挺好用的，比如接下来会实践的这一套nginx-ingress+externalIP+dns的方式就很直观而且方便自动化流程，大致策略如下:</p><p><strong>客户端 -> dns -> k8s-nginx-ingress-service(in ExternalIP) -> ingress-obj -> service -> pod</strong></p><p>kubernetes集群中具体工作的pod是由service做负载均衡和服务发现的，而service的外部发现策略通常有NodePort，Kube-proxy以及Ingress。对于内部服务暴露给外部，NodePort基本上是不好用的，因为本来Port就有限，而且如果是web服务(80,443)，需要接dns的，开在30000+端口以上，还得在外部做一个四层负载均衡，这样就很烦。Kube-proxy用在调试环境还行，同样有以上问题，所以Ingress是更好的选择。</p><p>nginx-ingress采用了nginx-lua模块实现upstream动态修正，无需reload nginx，可以解决上述提到的2x worker导致性能下降问题。且结合了service的pods自动发现(coredns)，轻松简单的完成很多过去很麻烦的任务。</p><p>首先在上篇blog里我们已经有了一个k8s集群，然后我们创建ingress-nginx相关的api对象</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/mandatory.yaml
</span></span><span class=line><span class=cl>kubectl apply -f mandatory.yaml
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#会创建好相应的ingress-nginx controller和rbac相关api</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@xxxxxxxx ingress-nginx<span class=o>]</span><span class=c1># kubectl get pods -n ingress-nginx</span>
</span></span><span class=line><span class=cl>NAME                                        READY   STATUS    RESTARTS   AGE
</span></span><span class=line><span class=cl>nginx-ingress-controller-5694ccb578-hwj2j   1/1     Running   <span class=m>0</span>          3h11m
</span></span></code></pre></div><p>然后我们创建一个ingress的service，用ExternalIP的方式暴露给集群外部</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=l>vim externalIp-ingress-service.yaml</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>ingress-nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>ingress-nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app.kubernetes.io/name</span><span class=p>:</span><span class=w> </span><span class=l>ingress-nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app.kubernetes.io/part-of</span><span class=p>:</span><span class=w> </span><span class=l>ingress-nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>http</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>protocol</span><span class=p>:</span><span class=w> </span><span class=l>TCP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>https</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>443</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>protocol</span><span class=p>:</span><span class=w> </span><span class=l>TCP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app.kubernetes.io/name</span><span class=p>:</span><span class=w> </span><span class=l>ingress-nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app.kubernetes.io/part-of</span><span class=p>:</span><span class=w> </span><span class=l>ingress-nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>externalIPs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c>#这里填写你的k8s masterip</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=m>10.1.33.159</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c>#将创建出如下服务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>[</span><span class=l>root@xxxxxxxxxxxx ingress-nginx]# kubectl get service -n ingress-nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=l>NAME            TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=l>ingress-nginx   ClusterIP   10.96.139.222   10.1.33.159   80/TCP,443/TCP   3h12m</span><span class=w>
</span></span></span></code></pre></div><p>接下来我们就可以创建具体的ingress对象了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=l>vim rook-ceph-ingress.yaml</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>extensions/v1beta1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Ingress</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>rook-ceph-ingress</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>annotations</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>nginx.ingress.kubernetes.io/ssl-redirect</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;false&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c>#要暴露的service对应的命名空间  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>rook-ceph</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>rules</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c>#这里按需配置,就是nginx的配置方法,具体查下ingress-nginx的项目文档</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>host</span><span class=p>:</span><span class=w> </span><span class=l>k8s-ceph-dashboard.calmkart.com</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>http</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>paths</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>backend</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>serviceName</span><span class=p>:</span><span class=w> </span><span class=l>rook-ceph-mgr-dashboard</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>servicePort</span><span class=p>:</span><span class=w> </span><span class=m>8443</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=l>kubectl apply -f rook-ceph-ingress.yaml</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c>#这个ingress将自动发现rook-ceph命名空间中的rook-ceph-mgr-dashboard服务，并将之作负载均衡对外暴露</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>[</span><span class=l>root@xxxxxxxxxxx ingress]# kubectl get service -n rook-ceph</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=l>NAME                      TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)             AGE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=l>rook-ceph-mgr             ClusterIP   10.99.37.148             9283/TCP            3h48m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=l>rook-ceph-mgr-dashboard   ClusterIP   10.110.163.110           8443/TCP            3h48m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=l>rook-ceph-mon-a           ClusterIP   10.103.5.55              6789/TCP,3300/TCP   3h49m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=l>rook-ceph-mon-b           ClusterIP   10.104.22.199            6789/TCP,3300/TCP   3h49m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=l>rook-ceph-mon-c           ClusterIP   10.110.80.82             6789/TCP,3300/TCP   3h49m</span><span class=w>
</span></span></span></code></pre></div><p>然后我们查看一下ingress状态</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@xxxxxxxxxx ingress<span class=o>]</span><span class=c1># kubectl get ingress -n rook-ceph</span>
</span></span><span class=line><span class=cl>NAME                HOSTS                                ADDRESS       PORTS   AGE
</span></span><span class=line><span class=cl>rook-ceph-ingress   k8s-ceph-dashboard.calmkart.com   10.1.33.159   <span class=m>80</span>      170m
</span></span></code></pre></div><p>这样就没问题了 最后我们把dns记录k8s-ceph-dashboard.calmkart.com指向10.1.33.159</p><p>搞定。</p><div class=archived-comments><h2>历史评论 (8 条)</h2><p class=comment-notice>以下评论来自原 WordPress 站点，仅作存档展示。</p><div class=comment-item><div class=comment-meta><strong>duboops</strong> (2019-05-25 18:19)</div><div class=comment-body>楼主采用的K8s负载均衡策略在性能上会优于传统的均衡策略么？</div></div><div class="comment-item comment-reply"><div class=comment-meta><strong>calmkart</strong> (2019-05-29 17:05)</div><div class=comment-body>我这个例子里基本上不会，因为实际上都是用的nginx作负载均衡.但在内部coredns的性能上可能会有一些提升.不过网络环境中的性能瓶颈一般不会出在负载均衡层.</div></div><div class=comment-item><div class=comment-meta><strong>hukerlet</strong> (2019-06-10 20:50)</div><div class=comment-body>看了楼主的文章，感觉您从事的工作是做基础架构么，好些文章写的真好，感觉您对k8s研究的很透彻。小弟刚从事运维工作没多久，最近工作中用到了容器，但对这方面是一知半解，不知道您能否抽空写些docker方面的文章呢，感激不尽。</div></div><div class="comment-item comment-reply"><div class=comment-meta><strong>calmkart</strong> (2019-06-11 11:05)</div><div class=comment-body>读书吧，入门《每天5分钟玩转docker》，进阶《Docker容器与容器云(第二版)》</div></div><div class=comment-item><div class=comment-meta><strong>linda_zhang</strong> (2019-06-27 16:20)</div><div class=comment-body>博主好，我是互动出版的约稿编辑，有幸阅读到您博客上的文章，感觉您的文章内容偏向入记录整理在工作中碰到的案例，内容质量上挺不错的，要是加以整理想必质量会更胜一筹，不知道您有没有考虑过将博客文章再次归纳整理下，并新增相关章节，集结出版呢，互动出版社主要是面向广大互联网读者推出相关技术书籍，目前年发行册数超过百万，在互联网读者中有较大的影响力。期待博主拨冗回复，详叙具体事宜。我的邮箱：329647550#qq.com (注：发送邮件时请将#号转为@)</div></div><div class=comment-item><div class=comment-meta><strong>xiaohua</strong> (2019-07-09 19:55)</div><div class=comment-body>楼主，我有个问题想向您请教下，我个人想往某一个技术方向去发展，比如成为k8s专家、或者mysql专家，但是感觉只钻研一个方向会不会以后的路会很窄，不知道您怎么看。</div></div><div class="comment-item comment-reply"><div class=comment-meta><strong>calmkart</strong> (2019-07-16 11:11)</div><div class=comment-body>看是哪种钻研了.讲道理一个某单方面的专家,其他方面也不会说完全不会.面学片精吧.</div></div><div class="comment-item comment-reply"><div class=comment-meta><strong>xiaohua</strong> (2019-07-17 11:43)</div><div class=comment-body>嗯嗯，您说的对，我也觉得往专家发展应该触类旁通，精通一点，也要了解其他的，要不然就是空中楼阁了，谢谢您的建议</div></div></div></section><footer class=article-footer><section class=article-tags><a href=/tags/dns/>Dns</a>
<a href=/tags/externalip/>Externalip</a>
<a href=/tags/ingress/>Ingress</a>
<a href=/tags/kubernetes/>Kubernetes</a>
<a href=/tags/nginx/>Nginx</a>
<a href=/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/>服务发现</a>
<a href=/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/>负载均衡</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/posts/2019/05/2019-05-24-kubernetes%E6%90%AD%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8rook-ceph%E7%9A%84pv%E5%AD%98%E5%82%A8/><div class=article-details><h2 class=article-title>kubernetes搭建并使用rook/ceph的pv存储</h2></div></a></article><article><a href=/posts/2019/04/2019-04-02-myip-calmkart-com%E8%8E%B7%E5%8F%96%E8%87%AA%E5%B7%B1%E7%9A%84%E5%87%BA%E5%8F%A3ip/><div class=article-details><h2 class=article-title>myip.calmkart.com获取自己的出口ip</h2></div></a></article><article><a href=/posts/2018/12/2018-12-29-macvlan%E5%AE%9E%E7%8E%B0k8s%E6%89%81%E5%B9%B32%E5%B1%82%E7%BD%91%E7%BB%9C/><div class=article-details><h2 class=article-title>macvlan实现k8s扁平2层网络</h2></div></a></article><article><a href=/posts/2018/07/2018-07-23-%E4%B8%80%E4%B8%AA%E8%87%AA%E8%A7%A3%E6%9E%90nginx-upstream%E5%92%8Clocation%E5%B9%B6%E6%A3%80%E6%B5%8B%E8%BF%9E%E9%80%9A%E6%80%A7%E7%9A%84web%E7%B3%BB%E7%BB%9F/><div class=article-details><h2 class=article-title>一个自解析nginx upstream和location并检测连通性的web系统</h2></div></a></article><article><a href=/posts/2018/04/2018-04-24-%E5%88%A9%E7%94%A8nginx_upload_module%E6%90%AD%E5%BB%BAhttp%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/><div class=article-details><h2 class=article-title>利用nginx_upload_module搭建http文件服务器</h2></div></a></article></div></div></aside><div id=tcomment></div><script src=https://cdn.jsdelivr.net/npm/twikoo@1.6.39/dist/twikoo.all.min.js></script><script>twikoo.init({envId:"",el:"#tcomment",lang:"zh-CN"})</script><footer class=site-footer><section class=copyright>&copy;
2026 cAlm的个人Blog</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=4.0.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><script type=module>
    import gallery from '\/ts\/gallery.js';

    const articleContent = document.querySelector('.article-content');
    const shouldLoad = articleContent && (articleContent.querySelectorAll('figure').length > 0 || articleContent.querySelectorAll('img.gallery-image').length > 0);
    
    if (shouldLoad) {
        gallery(articleContent);

        const PhotoSwipeLightbox = (await import("https:\/\/cdn.jsdelivr.net\/npm\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js")).default;
        const styleHref = "https:\/\/cdn.jsdelivr.net\/npm\/photoswipe@5.4.4\/dist\/photoswipe.css";

        const styleTag = document.createElement('link');
        styleTag.rel = 'stylesheet';
        styleTag.href = styleHref;
        document.head.appendChild(styleTag);

        const lightbox = new PhotoSwipeLightbox({
            gallerySelector: '.article-content',
            childSelector: 'figure a.image-link',
            pswpModule: () => import("https:\/\/cdn.jsdelivr.net\/npm\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js")
        });
        lightbox.init();
    }
</script></main></div><script type=text/javascript src=/ts/main.acaf849f2b273f6a8368a58b001f336738d0c948d92e79b116467d0c7515f932.js defer></script></body></html>