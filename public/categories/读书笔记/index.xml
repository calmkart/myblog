<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>读书笔记 on cAlm的个人Blog</title>
        <link>http://localhost:1313/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
        <description>Recent content in 读书笔记 on cAlm的个人Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 18 Sep 2019 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" /><item>
            <title>kubernetes scheduler流程图</title>
            <link>http://localhost:1313/posts/2019/09/2019-09-18-kubernetes-scheduler%E6%B5%81%E7%A8%8B%E5%9B%BE/</link>
            <pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2019/09/2019-09-18-kubernetes-scheduler%E6%B5%81%E7%A8%8B%E5%9B%BE/</guid>
            <description>&lt;p&gt;最近在跟着&lt;a class=&#34;link&#34; href=&#34;https://github.com/farmer-hutao/k8s-source-code-analysis&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;《k8s-1.13版本源码分析》&lt;/a&gt;读k8s源码，顺着流程把scheduler调度器模块过了一遍，文中有一幅k8s  scheduler调度器工作流程图画的不错，这里做个记录备忘。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/wp-content/uploads/2019/09/kube-scheduler-workflow.png&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;&lt;img src=&#34;images/kube-scheduler-workflow.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/a&gt;&lt;/p&gt;</description>
        </item><item>
            <title>《Python进阶》读书笔记(3)</title>
            <link>http://localhost:1313/posts/2017/11/2017-11-16-python%E8%BF%9B%E9%98%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03/</link>
            <pubDate>Thu, 16 Nov 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/11/2017-11-16-python%E8%BF%9B%E9%98%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03/</guid>
            <description>&lt;h4 id=&#34;16异常处理&#34;&gt;16.异常处理&#xA;&lt;/h4&gt;&lt;p&gt;捕获所有异常：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;except Exception as e:&#xA;    print e&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;try/except/finally语句:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;try:&#xA;    #首先执行&#xA;    pass&#xA;except:&#xA;    #异常的话执行&#xA;    pass&#xA;finally:&#xA;    #无论是否异常，在最后都执行&#xA;    pass&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;try/else语句：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;try:&#xA;    #首先执行&#xA;    pass&#xA;else:&#xA;    #异常的话执行,且不被捕获异常&#xA;    pass&#xA;finally:&#xA;    #无论是否异常，在最后都执行&#xA;    pass&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;17简易webserver&#34;&gt;17.简易webserver&#xA;&lt;/h4&gt;&lt;p&gt;python2:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;python -m SimpleHTTPServer 8888&#xA;#在当前文件夹建立简易http服务器，端口为8888&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;python3:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;python -m http.server 8888&#xA;#在当前文件夹建立简易http服务器，端口为8888&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，在python2中SimpleHTTPServer是处理GET和HEAD请求的，而CGIHTTPServer处理POST请求。&lt;/p&gt;&#xA;&lt;h4 id=&#34;18pprint&#34;&gt;18.pprint&#xA;&lt;/h4&gt;&lt;p&gt;可以用于打印dict等数据结构，比较漂亮&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from pprint import pprint&#xA;    pprint({a:1,b:2})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;19forelse从句&#34;&gt;19.for/else从句&#xA;&lt;/h4&gt;&lt;p&gt;else仅在for循环正常结束时才会执行，当for循环被break时，不执行else&lt;/p&gt;&#xA;&lt;p&gt;举例说明：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for item in container:&#xA;    if search_something(item):&#xA;        # Found it!&#xA;        process(item)&#xA;        break&#xA;else:&#xA;    # Didn&amp;#39;t find anything..&#xA;    not_found_in_container()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;20用with块自动释放句柄&#34;&gt;20.用with块自动释放句柄&#xA;&lt;/h4&gt;&lt;p&gt;with块可在有异常时，自动释放句柄&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;with open(&amp;#39;a.txt&amp;#39;,&amp;#39;r+&amp;#39;) as f:&#xA;#打开成功才会获得句柄，有异常则自动释放&#xA;    file = f.read()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用io.open可制定编码方式：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import io &#xA;with io.open(&amp;#39;a.txt&amp;#39;, &amp;#39;w&amp;#39;, encoding=&amp;#39;utf-8&amp;#39;) as f:&#xA;    f.write(.......)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而直接使用open(),do,close()的方式，可能因为各种error而导致没有释放资源。&lt;/p&gt;&#xA;&lt;h4 id=&#34;21协程&#34;&gt;21.协程&#xA;&lt;/h4&gt;&lt;p&gt;与生成器有点像，但生成器是返回可迭代对象的生产者，而携程是接受参数的消费者。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;def grep(pattern):&#xA;    print(&amp;#34;Searching for&amp;#34;, pattern)&#xA;    while True:&#xA;        line = (yield)&#xA;        if pattern in line:&#xA;            print(line)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们通过send方法传送给协程数据，然后用close()方法来关闭&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;search = grep(&amp;#39;coroutine&amp;#39;)&#xA;next(search)&#xA;#output: Searching for coroutine&#xA;search.send(&amp;#34;I love you&amp;#34;)&#xA;search.send(&amp;#34;Don&amp;#39;t you love me?&amp;#34;)&#xA;search.send(&amp;#34;I love coroutine instead!&amp;#34;)&#xA;#output: I love coroutine instead!&#xA;search = grep(&amp;#39;coroutine&amp;#39;)&#xA;search.close()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=124&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;《Python进阶》读书笔记(1)&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=139&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;《Python进阶》读书笔记(2)&lt;/a&gt;&lt;/p&gt;</description>
        </item><item>
            <title>《Python进阶》读书笔记(1)</title>
            <link>http://localhost:1313/posts/2017/11/2017-11-15-python%E8%BF%9B%E9%98%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/</link>
            <pubDate>Wed, 15 Nov 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/11/2017-11-15-python%E8%BF%9B%E9%98%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/</guid>
            <description>&lt;h4 id=&#34;1args与kwargs传参不定长传参&#34;&gt;&lt;strong&gt;1.*args与**kwargs传参(不定长传参)&lt;/strong&gt;&#xA;&lt;/h4&gt;&lt;p&gt;其中*args是列表传参,**kwargs是字典传参&lt;/p&gt;&#xA;&lt;p&gt;使用举例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;function(fargs, *args, **kwargs)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以用function(1)，function([1,2])，function({a:1})调用函数，都没问题。&lt;/p&gt;&#xA;&lt;h4 id=&#34;2生成器yield&#34;&gt;&lt;strong&gt;2.生成器yield&lt;/strong&gt;&#xA;&lt;/h4&gt;&lt;p&gt;可理解为只能被迭代一次的迭代器，可以节省内存&lt;/p&gt;&#xA;&lt;p&gt;使用举例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;def generation_function():&#xA;    for i in range(10):&#xA;        yield i&#xA;&#xA;for item in generation_function():&#xA;#generation_function是生成器，可被迭代的&#xA;    print item&#xA;#输出是0-&amp;gt;9，但并不需要建立一个list，节省了内存&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;3匿名函数&#34;&gt;&lt;strong&gt;3.匿名函数&lt;/strong&gt;&#xA;&lt;/h4&gt;&lt;p&gt;lambda，可减少无需重复函数&lt;/p&gt;&#xA;&lt;p&gt;格式：lambda 参数:操作&lt;/p&gt;&#xA;&lt;p&gt;使用举例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;lambda x : x+1&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;4map&#34;&gt;&lt;strong&gt;4.map()&lt;/strong&gt;&#xA;&lt;/h4&gt;&lt;p&gt;将function应用于后面参数的所有LIST元素中，返回结果。(python2返回list,python3返回迭代器)&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;map(function, list)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也支持多参数:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;map(function, list1, list2, list3....)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;常结合lambda匿名函数一起使用&lt;/p&gt;&#xA;&lt;p&gt;使用举例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;items=[1,2,3,4,5]&#xA;print map(lambda x : x**2, items)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出[1,4,9,16,25]&lt;/p&gt;&#xA;&lt;p&gt;map的本质既将一个函数映射到若干列表的所有元素上。&lt;/p&gt;&#xA;&lt;h4 id=&#34;5filter&#34;&gt;5.filter()&#xA;&lt;/h4&gt;&lt;p&gt;过滤list中的元素，返回符合条件元素的list&lt;/p&gt;&#xA;&lt;p&gt;使用举例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;number_list = range(-5,5)&#xA;less_than_zero = filter(lambda x : x&amp;lt;0, number_list)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出[-5,-4,-3,-2,-1]&lt;/p&gt;&#xA;&lt;h4 id=&#34;6reduce&#34;&gt;6.reduce()&#xA;&lt;/h4&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from functools import reduce)&#xA;product = reduce((lambda x,y:x*y),[1,2,3,4])&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出24&lt;/p&gt;&#xA;&lt;h4 id=&#34;7set&#34;&gt;7.set&#xA;&lt;/h4&gt;&lt;p&gt;集合既不能包含重复值(其他行为与list相似)&lt;/p&gt;&#xA;&lt;p&gt;语法：set(list)&lt;/p&gt;&#xA;&lt;p&gt;交集：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print (set1.intersection(set2))&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;差集：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print (set1.difference(set2))&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;8三元运算符&#34;&gt;8.三元运算符&#xA;&lt;/h4&gt;&lt;p&gt;使用举例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;is_fat = True&#xA;state = &amp;#34;fat&amp;#34; if is_fat else &amp;#34;not fat&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=139&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;《Python进阶》读书笔记(2)&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=150&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;《Python进阶》读书笔记(3)&lt;/a&gt;&lt;/p&gt;</description>
        </item><item>
            <title>《Python进阶》读书笔记(2)</title>
            <link>http://localhost:1313/posts/2017/11/2017-11-15-python%E8%BF%9B%E9%98%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02/</link>
            <pubDate>Wed, 15 Nov 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/11/2017-11-15-python%E8%BF%9B%E9%98%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02/</guid>
            <description>&lt;h4 id=&#34;9装饰器&#34;&gt;9.装饰器&#xA;&lt;/h4&gt;&lt;p&gt;既将函数传参给装饰器函数，在函数执行的上下文作某些通用操作。&lt;/p&gt;&#xA;&lt;p&gt;记得要用@wraps复制函数名称(__name__)，等等属性&lt;/p&gt;&#xA;&lt;p&gt;使用举例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from functools import wraps&#xA;&#xA;def requires_auth(f):&#xA;    @wraps(f)&#xA;    def decorated(*args, **kwargs):&#xA;        auth = request.authorization&#xA;        if not auth or not check_auth(auth.username, auth.password):&#xA;            #若未登录，返回401&#xA;            authenticate()&#xA;        return f(*args, **kwargs)&#xA;    return decorated&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;10可变数据类型和不可变数据类型&#34;&gt;10.可变数据类型和不可变数据类型&#xA;&lt;/h4&gt;&lt;p&gt;可变数据类型：list,dict&lt;/p&gt;&#xA;&lt;p&gt;不可变数据类型：int,float,string,tuple&lt;/p&gt;&#xA;&lt;p&gt;可变不可变，指的是变量指向的值：可变，就是说可以改变指向的值而地址不变。不可变，就是说改变变量的值必然改变地址。&lt;/p&gt;&#xA;&lt;p&gt;python中的赋值(=)，就是左侧得到右侧内存的引用。&lt;/p&gt;&#xA;&lt;p&gt;举例说明：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a = [1]&#xA;print a  #----&amp;gt;[1]&#xA;b = a&#xA;b.append(2)&#xA;print a #-----&amp;gt;[1,2]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为list为可变数据类型，而a和b指向同一片内存。当对b做+=操作时，只是向后扩充内存内容，而不会修改内存位置。所以a也改变了。&lt;/p&gt;&#xA;&lt;p&gt;同时要注意，python函数被定义时，默认参数只会被计算一次，不会每次都计算。所以，默认参数最好不要用可变数据类型，就算要用，也要注意在之后不要对其做修改。&lt;/p&gt;&#xA;&lt;h4 id=&#34;11__slots__&#34;&gt;11.__slots__&#xA;&lt;/h4&gt;&lt;p&gt;在类的定义中使用__slots__=[&amp;ldquo;name&amp;rdquo;,&amp;ldquo;age&amp;rdquo;]，则只有__slots__这个set中的属性可以被分配内存，不在其中的不可被分配内存。&lt;/p&gt;&#xA;&lt;h4 id=&#34;12容器collections&#34;&gt;12.容器collections&#xA;&lt;/h4&gt;&lt;p&gt;1.defaultdict&lt;/p&gt;&#xA;&lt;p&gt;调用不存在的key时，会用默认的工厂方法作为key默认值.&lt;/p&gt;&#xA;&lt;p&gt;举例说明：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from collections import defaultdic&#xA;&#xA;favourite_colors = defaultdict(list)&#xA;for name,color in colors:&#xA;    favourite_colors[name].append(color)&#xA;    #默认用name这个list作为KEY&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.counter计数器&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from collections import counter&#xA;c= counter(...)#为内部元素计数&#xA;favs = counter(name for name,color in colors)&#xA;#为name计数,以dict返回&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.deque双向链表&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from collections import deque&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.namedtuple命名元组&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from collections import namedtuple&#xA;&#xA;animal = namedtuple(&amp;#39;animal&amp;#39;, &amp;#39;name age type&amp;#39;)&#xA;perry = animal(name=&amp;#34;perry&amp;#34;, age=31, type=&amp;#34;cat&amp;#34;)&#xA;#可以访问perry.name这样访问属性&#xA;print perry.name&#xA;#输出perry&#xA;#可将命名元组转换为dict，用_asdict()方法&#xA;perry._asdict()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;13dir&#34;&gt;13.dir()&#xA;&lt;/h4&gt;&lt;p&gt;返回对象所有属性和方法&lt;/p&gt;&#xA;&lt;p&gt;举例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a = [1,2,3]&#xA;print dir(a)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;14type和id&#34;&gt;14.type()和id()&#xA;&lt;/h4&gt;&lt;p&gt;type()返回对象类型，id()返回不同种类对象唯一ID&lt;/p&gt;&#xA;&lt;h4 id=&#34;15推导式&#34;&gt;15.推导式&#xA;&lt;/h4&gt;&lt;p&gt;1.列表推导式&lt;/p&gt;&#xA;&lt;p&gt;通过for和if生成list&lt;/p&gt;&#xA;&lt;p&gt;举例说明：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;m=[i for i in range(30) if i%3 is 0]&#xA;#------------这是list-----这是条件-----&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;语法：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;variable = [out_exp for out_exp in input_list if out_exp==2]&#xA;#----------------------------------这是list------这是条件----&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.字典推导式&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;dict = {v:k for k,v in some_dict.items()}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=124&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;《Python进阶》读书笔记(1)&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=150&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;《Python进阶》读书笔记(3)&lt;/a&gt;&lt;/p&gt;</description>
        </item></channel>
</rss>
