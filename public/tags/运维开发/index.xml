<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>运维开发 on cAlm的个人Blog</title>
        <link>http://localhost:1313/tags/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/</link>
        <description>Recent content in 运维开发 on cAlm的个人Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 25 Dec 2019 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml" /><item>
            <title>琐事繁多是不是一定不好?</title>
            <link>http://localhost:1313/posts/2019/12/2019-12-25-%E7%90%90%E4%BA%8B%E7%B9%81%E5%A4%9A%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B8%80%E5%AE%9A%E4%B8%8D%E5%A5%BD/</link>
            <pubDate>Wed, 25 Dec 2019 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2019/12/2019-12-25-%E7%90%90%E4%BA%8B%E7%B9%81%E5%A4%9A%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B8%80%E5%AE%9A%E4%B8%8D%E5%A5%BD/</guid>
            <description>&lt;p&gt;摘抄自 《SRE: Google运维解密》&lt;/p&gt;&#xA;&lt;p&gt;字字珠玑。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;琐事不会总是让每个人都不开心，特别是不太多的时候。已知的和重复性的工作有一种让人平静的功效。完成这些事可以带来一种满足感和快速胜利感。琐事可能是低风险低压力的活动，有些员工甚至喜欢做这种类型的工作。&lt;/p&gt;&#xA;&lt;p&gt;琐事的存在并不总是坏事，但是每个人都必须清楚，在SRE所扮演的角色中，一定数量的琐事是不可避免的，这其实是任何工程类工作都具有的特点。少量的琐事存在不是什么大问题。但是一旦琐事的数量变多，就会有害了。如果琐事特别繁重，那就应该非常担扰，大声抱怨。在许多琐事有害的原因中，有如下因素需要考虑：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;职业停滞&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果花在工程项目上的时间太少，你的职业发展会变慢，甚至停滞。Google确实会奖励做那些脏活累活的人，但是仅仅是该工作是不可避免，并有巨大的正面影响的时候才会这样做。没有人可以通过不停地做脏活累活满足自己的职业发展。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;士气低落&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;每个人对自己可以承担的琐事限度有所不同，但是一定有个限度。过多的琐事会导致过度劳累，疲倦和不满。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;另外，牺牲工程实践而做琐事会对SRE组织的整体发展造成损害，原因如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;造成误解&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们努力确保每个SRE以及与SRE一起工作的人都理解SRE是一个工程组织。如果个人或团队过度参与琐事，会破坏这种角色，造成误解。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;进展缓慢&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;琐事过多会导致团队生产力下降，如果SRE团队忙于为手工操作和导出数据救火，新功能的发布就会变慢。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;开创先例&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果SRE过于愿意承担琐事，研发同事就更倾向于加入更多的琐事，有时候甚至将本该由研发团队承担的运维工作转给SRE来承担。其他团队也会开始指望SRE接受这样的工作，这显然是不好的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;促进摩擦产生&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;即使你个人对琐事没有怨言，你现在的或未来的队友可能会很不开心。如果团队中引入了太多的琐事，其实就是在鼓励团队里最好的工程师开始寻找其他地方提供的更有价值的工作。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;违反承诺&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;那些为了项目工程工作而入职的新员工，以及转入SRE的老员工会有被欺骗的感觉，这非常不利于公司的士气。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;如果我们都致力于每一周通过工程工作消除一点琐事，就可以持续性地整顿服务。我们就可以将更多的力量投入到扩大服务规模的工程工作上去，或者是进行下一代的服务的架构设计，又或者是建立一套跨SRE使用的工具链。让我们多创新，少干琐事吧！&lt;/p&gt;</description>
        </item><item>
            <title>kubernetes搭建并使用rook/ceph的pv存储</title>
            <link>http://localhost:1313/posts/2019/05/2019-05-24-kubernetes%E6%90%AD%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8rook-ceph%E7%9A%84pv%E5%AD%98%E5%82%A8/</link>
            <pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2019/05/2019-05-24-kubernetes%E6%90%AD%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8rook-ceph%E7%9A%84pv%E5%AD%98%E5%82%A8/</guid>
            <description>&lt;p&gt;k8s中pod的存储在非单节点是不支持hostpath的，都得用各种分布式存储来实现.每个pvc对应的pv手工创建也很不现实,试了下rook-ceph分布式存储的搞法，感觉不错.其中也还是遇到了很多坑,这里稍微记录一下.&lt;/p&gt;&#xA;&lt;p&gt;首先有一个三个节点的k8s集群 &lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/wp-content/uploads/2019/05/111.png&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;&lt;img src=&#34;images/111.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/a&gt; 首先创建rook-ceph-common&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;wget https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/common.yaml&#xA;kubectl apply -f common.yaml&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后创建rook-ceph-operator&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;wget https://raw.githubusercontent.com/rook/rook/release-1.0/cluster/examples/kubernetes/ceph/operator.yaml&#xA;kubectl apply -f operator.yaml&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上两步基本上不会出啥问题,标准配置 接下来创建cluster的问题比较多,贴上我的配置&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vim cluster.yaml&#xA;&#xA;apiVersion: ceph.rook.io/v1&#xA;kind: CephCluster&#xA;metadata:&#xA;  name: rook-ceph&#xA;  namespace: rook-ceph&#xA;spec:&#xA;  cephVersion:&#xA;    image: ceph/ceph:v14.2.1-20190430&#xA;    allowUnsupported: true&#xA;  #设置data路径到自己规划的路径&#xA;  dataDirHostPath: /home/shared/rook&#xA;  mon:&#xA;    count: 3&#xA;    allowMultiplePerNode: true&#xA;  dashboard:&#xA;    enabled: true&#xA;    port: 8443&#xA;    urlPrefix: /&#xA;    #关闭https&#xA;    ssl: false&#xA;  network:&#xA;    #如要在k8s集群外使用,这里可以打开&#xA;    hostNetwork: false&#xA;  rbdMirroring:&#xA;    workers: 0&#xA;  storage:&#xA;    #全节点使用&#xA;    useAllNodes: true&#xA;    useAllDevices: false&#xA;    deviceFilter:&#xA;    config:&#xA;      osdsPerDevice: &amp;#34;1&amp;#34;&#xA;    directories:&#xA;    - path: /home/shared/rook&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kubectl apply -f cluster.yaml&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看部署情况 &lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/wp-content/uploads/2019/05/2.png&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;&lt;img src=&#34;images/2.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/a&gt; 这样就基本上没问题了,k8s中的每个Node会启两个pod(rook-ceph-agent和rook-discover),并且mgr和osd都没问题。 然后给ceph-dashboard提供NodePort的外部访问service&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vim dashboard-external-http.yaml&#xA;&#xA;apiVersion: v1&#xA;kind: Service&#xA;metadata:&#xA;  name: rook-ceph-mgr-dashboard-external-https&#xA;  namespace: rook-ceph&#xA;  labels:&#xA;    app: rook-ceph-mgr&#xA;    rook_cluster: rook-ceph&#xA;spec:&#xA;  ports:&#xA;  - name: dashboard&#xA;    port: 8443&#xA;    protocol: TCP&#xA;    targetPort: 8443&#xA;  selector:&#xA;    app: rook-ceph-mgr&#xA;    rook_cluster: rook-ceph&#xA;  sessionAffinity: None&#xA;  type: NodePort&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kubectl apply -f dashboard-external-https.yaml&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后查看下service的情况,是否正常 &lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/wp-content/uploads/2019/05/3.png&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;&lt;img src=&#34;images/3.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/a&gt; 这样就对了,可以访问一下http://&lt;!-- raw HTML omitted --&gt;:&lt;!-- raw HTML omitted --&gt;，看看是不是能进ceph-dashboard&lt;/p&gt;&#xA;&lt;p&gt;一般情况下问题不大,查看admin的默认密码&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kubectl -n rook-ceph get secret rook-ceph-dashboard-password -o jsonpath=&amp;#34;{[&amp;#39;data&amp;#39;][&amp;#39;password&amp;#39;]}&amp;#34; | base64 --decode &amp;amp;&amp;amp; echo&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是admin登陆进去了之后，肯定会疯狂500错误，查了下官方的issue，这里有bug。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;解决办法是:&lt;/strong&gt; &lt;strong&gt;在dashboard里创建一个新role角色(右上角用户管理,roles)，把权限全钩上，然后去掉iscsi的所有权限。&lt;/strong&gt; &lt;strong&gt;接着创建一个新用户,绑定这个新的role角色,最后用新用户登陆&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;接着创建pool和storage用于自动生成pvc匹配的pv&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vim storageclass.yaml&#xA;&#xA;apiVersion: ceph.rook.io/v1&#xA;kind: CephBlockPool&#xA;metadata:&#xA;  name: replicapool&#xA;  namespace: rook-ceph&#xA;spec:&#xA;  replicated:&#xA;    size: 2&#xA;---&#xA;apiVersion: storage.k8s.io/v1&#xA;kind: StorageClass&#xA;metadata:&#xA;   name: rook-ceph-block&#xA;provisioner: ceph.rook.io/block&#xA;parameters:&#xA;  blockPool: replicapool&#xA;  clusterNamespace: rook-ceph&#xA;  fstype: xfs&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kubectl apply -f storagecalss.yaml&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建pool和storage之后通过dashboard或者命令 kubectl get cephcluster -n rook-ceph 查看一下集群是否health，如果是health就没毛病了&lt;/p&gt;&#xA;&lt;p&gt;最后测试一下申请一个pvc看看是否会自动生成pv与之绑定&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1&#xA;kind: PersistentVolumeClaim&#xA;metadata:&#xA;  name: jenkins-home&#xA;  namespace: kube-ops&#xA;  labels:&#xA;    app: jenkins-home&#xA;spec:&#xA;  storageClassName: rook-ceph-block&#xA;  accessModes:&#xA;  - ReadWriteOnce&#xA;  resources:&#xA;    requests:&#xA;      storage: 20Gi&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/wp-content/uploads/2019/05/%e4%bc%81%e4%b8%9a%e5%be%ae%e4%bf%a1%e6%88%aa%e5%9b%be_dd2a2f8b-10fb-4f3f-8d21-bbaa31a4ba7d.png&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;&lt;img src=&#34;images/%e4%bc%81%e4%b8%9a%e5%be%ae%e4%bf%a1%e6%88%aa%e5%9b%be_dd2a2f8b-10fb-4f3f-8d21-bbaa31a4ba7d.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/a&gt; 可见，管用了.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;外加一些小tips:&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果rook-ceph配置有误需要还原重新配置,一定要遵循官方的清理步骤 &lt;a class=&#34;link&#34; href=&#34;https://rook.github.io/docs/rook/v1.0/ceph-teardown.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://rook.github.io/docs/rook/v1.0/ceph-teardown.html&lt;/a&gt; 切记要删除掉所有k8s的node上配置的data文件夹,不然会导致新集群无法初始化.&lt;/p&gt;&#xA;&lt;p&gt;创建不出pod很多都是权限原因或者node无法调度,需要检查下rbac权限设置或者各个node的情况.&lt;/p&gt;&#xA;&lt;p&gt;最后附上rook项目的github地址: &lt;a class=&#34;link&#34; href=&#34;https://github.com/rook/rook&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/rook/rook&lt;/a&gt;&lt;/p&gt;</description>
        </item><item>
            <title>python操作ldap</title>
            <link>http://localhost:1313/posts/2018/09/2018-09-28-python%E6%93%8D%E4%BD%9Cldap/</link>
            <pubDate>Fri, 28 Sep 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/09/2018-09-28-python%E6%93%8D%E4%BD%9Cldap/</guid>
            <description>&lt;p&gt;封装了一个python的ldap常用操作类&lt;/p&gt;&#xA;&lt;p&gt;首先pip装库&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pip install python-ldap&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后开始代码部分&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# -*- coding:utf-8 -*-&#xA;from __future__ import absolute_import&#xA;&#xA;import binascii&#xA;import hashlib&#xA;from base64 import b64encode&#xA;&#xA;import ldap&#xA;import ldap.modlist as modlist&#xA;&#xA;from common.common import log&#xA;&#xA;class MyLdap():&#xA;     &#xA;    def __init__(self,ldap_host=None,base_dn=None,user=None,password=None):&#xA;        self.base_dn = base_dn&#xA;        self.ldap_host = ldap_host&#xA;        self.user = user&#xA;        self.password = password&#xA;        try:&#xA;            self.ldapconn = ldap.initialize(ldap_host)&#xA;            self.ldapconn.simple_bind(user,password)&#xA;        except ldap.LDAPError,e:&#xA;            log().error(str(e))&#xA;            print e&#xA;&#xA;    @property&#xA;    def status(self):&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        验证初始化ldap账号密码,以及ldap地址是否正确&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        ldap_client = ldap.initialize(self.ldap_host)&#xA;        try:&#xA;            ldap_client.simple_bind_s(self.user, self.password)&#xA;            ldap_client.unbind_s()&#xA;            return {&amp;#34;status&amp;#34;:True}&#xA;        except Exception as e:&#xA;            log().error(str(e))&#xA;            return {&amp;#34;status&amp;#34;:False, &amp;#34;msg&amp;#34;:&amp;#34;ldap初始化管理员账号密码或ldap地址有误,详情:{0}&amp;#34;.format(str(e))}&#xA;&#xA;    def _ldap_search_dn(self,uid=None):&#xA;        obj = self.ldapconn&#xA;        obj.protocal_version = ldap.VERSION3&#xA;        searchScope = ldap.SCOPE_SUBTREE&#xA;        retrieveAttributes = None &#xA;        searchFilter = &amp;#34;cn=&amp;#34; + uid&#xA;        &#xA;        try:&#xA;            ldap_result_id = obj.search(self.base_dn, searchScope, searchFilter, retrieveAttributes)&#xA;            result_type, result_data = obj.result(ldap_result_id, 0)&#xA;            if result_type == ldap.RES_SEARCH_ENTRY:&#xA;                return result_data[0][0]&#xA;            else:&#xA;                return None&#xA;        except ldap.LDAPError, e:&#xA;            log().error(str(e))&#xA;&#xA;    def ldap_get_user(self,uid=None):&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        获取ldap用户详情,失败返None&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        obj = self.ldapconn&#xA;        obj.protocal_version = ldap.VERSION3&#xA;        searchScope = ldap.SCOPE_SUBTREE&#xA;        retrieveAttributes = None &#xA;        searchFilter = &amp;#34;cn=&amp;#34; + uid&#xA;        try:&#xA;            ldap_result_id = obj.search(self.base_dn, searchScope, searchFilter, retrieveAttributes)&#xA;            result_type, result_data = obj.result(ldap_result_id, 0)&#xA;            if result_type == ldap.RES_SEARCH_ENTRY:&#xA;                username = result_data[0][1][&amp;#39;cn&amp;#39;][0]&#xA;                mail = result_data[0][1][&amp;#39;mail&amp;#39;][0]&#xA;                displayName = result_data[0][1][&amp;#39;displayName&amp;#39;][0]&#xA;                sn = result_data[0][1][&amp;#39;sn&amp;#39;][0]&#xA;                result = {&amp;#39;username&amp;#39;:username,&amp;#39;mail&amp;#39;:mail,&amp;#39;displayName&amp;#39;:displayName, &amp;#39;sn&amp;#39;:sn}&#xA;                return result&#xA;            else:&#xA;                return None&#xA;        except ldap.LDAPError, e:&#xA;            log().error(str(e))&#xA;    &#xA;    def ldap_get(self,uid=None,passwd=None):&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        验证ldap账号密码,成功返True,失败返False&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        target_cn = self._ldap_search_dn(uid)&#xA;        if not target_cn:&#xA;            return False   &#xA;        try:&#xA;            client = ldap.initialize(self.ldap_host)&#xA;            client.simple_bind_s(target_cn,passwd)&#xA;            client.unbind_s()&#xA;            return True&#xA;        except ldap.LDAPError,e:&#xA;            log().error(str(e))&#xA;            return False&#xA;&#xA;    &#xA;    def cnupdatepass(self, cn, passwd):&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        更改ldap密码,成功返True,失败返error&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        dn=&amp;#39;cn={0},{1}&amp;#39;.format(cn, self.base_dn)&#xA;        try:&#xA;            result=self.ldapconn.search_s(dn, ldap.SCOPE_SUBTREE, &amp;#39;cn=%s&amp;#39; % cn)&#xA;            oldpass=result[0][1][&amp;#39;userPassword&amp;#39;]&#xA;            oldwifipass=result[0][1][&amp;#39;sambaNTPassword&amp;#39;]&#xA;            newpass=&amp;#39;{MD5}&amp;#39; + b64encode(hashlib.md5(passwd).digest())&#xA;            wifipass=binascii.hexlify(hashlib.new(&amp;#39;md4&amp;#39;, passwd.encode(&amp;#39;utf-16le&amp;#39;)).digest())&#xA;            old={&amp;#39;userPassword&amp;#39;:oldpass,&amp;#39;sambaNTPassword&amp;#39;: oldwifipass}&#xA;            new={&amp;#34;sambaNTPassword&amp;#34;: [wifipass],&amp;#34;userPassword&amp;#34;:[newpass]}&#xA;            mlist = modlist.modifyModlist(old, new)&#xA;            self.ldapconn.modify_s(dn, mlist)&#xA;            return {&amp;#34;status&amp;#34;:True}&#xA;        except ldap.LDAPError as e:&#xA;            log().error(str(e))&#xA;            return {&amp;#34;status&amp;#34;:False, &amp;#34;msg&amp;#34;:&amp;#34;ldap更改密码错误,详情: {0}&amp;#34;.format(str(e))}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用时&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ldap_client = MyLdap(ldap_url, base_dn, admin, password)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码注释已经写的很清楚了感觉,不再写详情了,本文做个备忘&lt;/p&gt;</description>
        </item><item>
            <title>django生成图片验证码</title>
            <link>http://localhost:1313/posts/2018/09/2018-09-18-django%E7%94%9F%E6%88%90%E7%99%BB%E5%BD%95%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/</link>
            <pubDate>Tue, 18 Sep 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/09/2018-09-18-django%E7%94%9F%E6%88%90%E7%99%BB%E5%BD%95%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/</guid>
            <description>&lt;p&gt;最近在做一个好玩的通用django单点登录系统，登录系统少不了验证码，参考了一下别人的做法和开源项目，总结一下。&lt;/p&gt;&#xA;&lt;p&gt;结果如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;images/%e4%bc%81%e4%b8%9a%e5%be%ae%e4%bf%a1%e6%88%aa%e5%9b%be_837b19bb-98df-4c26-afae-6678c91ff47a.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;主要思路流程是，后端根据随机码绘图，然后做混淆(我这里几乎没做模糊之类的混淆)，最后将随机验证码写进后端session里，前端获取图像后，提交时与session里的验证码做比较。流程还是比较简单的，大致代码如下。&lt;/p&gt;&#xA;&lt;p&gt;1.captcha_handle.py&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;captcha_handle.py&#xA;#用于生成随机字符串以及生成验证码图片&#xA;&#xA;# -*- coding:utf-8 -*-&#xA;import random,string&#xA;from PIL import Image,ImageDraw,ImageFont,ImageFilter&#xA;&#xA;#生成随机字符串&#xA;def _getRandomChar():&#xA;    #string模块包含各种字符串，以下为小写字母加数字&#xA;    ran = string.ascii_lowercase+string.digits&#xA;    char = &amp;#39;&amp;#39;&#xA;    for i in range(4):&#xA;        char += random.choice(ran)&#xA;    return char&#xA;&#xA;#返回一个随机的RGB颜色&#xA;def _getRandomColor():&#xA;    return (random.randint(50,150),random.randint(50,150),random.randint(50,150))&#xA;&#xA;def create_captcha():&#xA;&#xA;    #创建图片，模式，大小，背景色&#xA;    img = Image.new(&amp;#39;RGB&amp;#39;, (120,30), (255,255,255))&#xA;    #创建画布&#xA;    draw = ImageDraw.Draw(img)&#xA;    #设置字体&#xA;    font = ImageFont.truetype(&amp;#39;Arial.ttf&amp;#39;, 25)&#xA;&#xA;    code = _getRandomChar()&#xA;    #将生成的字符画在画布上&#xA;    for t in range(4):&#xA;        draw.text((30*t+5,0),code[t],_getRandomColor(),font)&#xA;&#xA;    #生成干扰点&#xA;    for _ in range(random.randint(0,50)):&#xA;        #位置，颜色&#xA;        draw.point((random.randint(0, 120), random.randint(0, 30)),fill=_getRandomColor())&#xA;&#xA;    #使用模糊滤镜使图片模糊&#xA;    # img = img.filter(ImageFilter.BLUR)&#xA;    #保存&#xA;    #img.save(&amp;#39;&amp;#39;.join(code)+&amp;#39;.jpg&amp;#39;,&amp;#39;jpeg&amp;#39;)&#xA;    return img,code&#xA;&#xA;if __name__ == &amp;#39;__main__&amp;#39;:&#xA;    create_code()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.views.py&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;views.py&#xA;#视图，生成验证码图片和code，返回图片，code存进session&#xA;class get_captcha(View):&#xA;&#xA;    def get(self, request):&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        生成验证码图片和验证码code,返回验证码图片,并以形式将验证码存放在session里&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        try:&#xA;            f = BytesIO()&#xA;            img, code = create_captcha()&#xA;            request.session[&amp;#34;captcha&amp;#34;] = code&#xA;            img.save(f,&amp;#39;PNG&amp;#39;)&#xA;            return HttpResponse(f.getvalue())&#xA;        except Exception as e:&#xA;            log().error(str(e))&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.login.html&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{# html #}&#xA;&amp;lt;div class=&amp;#34;col-xs-4&amp;#34;&amp;gt;&#xA;    &amp;lt;img id=&amp;#34;captcha_img&amp;#34; src=&amp;#34;{% url &amp;#39;get_captcha&amp;#39; %}&amp;#34; onclick=&amp;#34;refresh_captcha()&amp;#34; style=&amp;#34;margin-top: 28px;&amp;#34;&amp;gt;&#xA;    &amp;lt;p class=&amp;#34;help-block&amp;#34; onclick=&amp;#34;refresh_captcha()&amp;#34;&amp;gt;&#xA;    看不清楚?换一张!&#xA;    &amp;lt;/p&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&#xA;{# js #}&#xA;&amp;lt;script&amp;gt;&#xA;    //刷新验证码&#xA;    function refresh_captcha() {&#xA;        $(&amp;#34;#captcha_img&amp;#34;).attr(&amp;#34;src&amp;#34;,$(&amp;#34;#captcha_img&amp;#34;)[0].src + &amp;#39;?&amp;#39;);&#xA;    };&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.url.py&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;url(r&amp;#39;^get_captcha/$&amp;#39;,cas_views.get_captcha.as_view(), name=&amp;#34;get_captcha&amp;#34;),&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.views.py&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#校验验证码是否正确&#xA;if request.session[&amp;#34;captcha&amp;#34;].lower() != captcha.lower():&#xA;    return JsonResponse({&amp;#34;status&amp;#34;:False, &amp;#34;msg&amp;#34;:&amp;#34;验证码错误!&amp;#34;})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一些代码是参考网络上其他开源代码，不过其实也挺简单的，熟悉request.session就差不多了。做个记录。&lt;/p&gt;</description>
        </item><item>
            <title>django类视图装饰器</title>
            <link>http://localhost:1313/posts/2018/09/2018-09-18-django%E7%B1%BB%E8%A7%86%E5%9B%BE%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
            <pubDate>Tue, 18 Sep 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/09/2018-09-18-django%E7%B1%BB%E8%A7%86%E5%9B%BE%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
            <description>&lt;p&gt;一点关于django类视图装饰器的小笔记。&lt;/p&gt;&#xA;&lt;p&gt;django类视图是很常用的，对于传统的函数视图来说，装饰器可以直接装饰函数，但类视图，装饰器无法直接装饰类方法。&lt;/p&gt;&#xA;&lt;p&gt;比较了几种常见的解决方法,个人觉得比较优雅的解决方法如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from django.shortcuts import render&#xA;from django.utils.decorators import method_decorator&#xA;from django.views.decorators.csrf import csrf_exempt&#xA;from django.views.generic import View&#xA;&#xA;@method_decorator(csrf_exempt, name=&amp;#34;dispatch&amp;#34;)&#xA;class login(View):&#xA;&#xA;    @method_decorator(auth_login)&#xA;    def get(self, request, username):&#xA;        #....func...&#xA;        return render(request, &amp;#39;login.html&amp;#39;, {&amp;#34;displayName&amp;#34;:username, &amp;#34;admin_flag&amp;#34;:admin_flag})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;既如以上代码，将装饰器函数传给method_decorator方法，直接修饰视图类方法。&lt;/p&gt;&#xA;&lt;p&gt;也可直接修饰视图类，对于需要修饰的方法，用name参数的形式传入method_decorator中即可，但感觉不够优雅。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from django.shortcuts import render&#xA;from django.utils.decorators import method_decorator&#xA;from django.views.decorators.csrf import csrf_exempt&#xA;from django.views.generic import View&#xA;&#xA;@method_decorator(csrf_exempt, name=&amp;#34;dispatch&amp;#34;)&#xA;@method_decorator(auth_login, name=&amp;#34;get&amp;#34;)&#xA;class login(View):&#xA;&#xA;    def get(self, request, username):&#xA;        #....func...&#xA;        return render(request, &amp;#39;login.html&amp;#39;, {&amp;#34;displayName&amp;#34;:username, &amp;#34;admin_flag&amp;#34;:admin_flag})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要稍微注意的是，csrf_exempt跨站排除装饰器，只能修饰在类视图的dispatch方法上，既原始写法如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class login(View):&#xA;    &#xA;    @method_decorator(csrf_exempt)&#xA;    def dispatch(self, request, *args, **kwargs):&#xA;        return super(login,self).dispatch(request,*args,**kwargs)&#xA;    &#xA;    def get(self, request, username):&#xA;        #....func...&#xA;        return render(request, &amp;#39;login.html&amp;#39;, {&amp;#34;displayName&amp;#34;:username, &amp;#34;admin_flag&amp;#34;:admin_flag})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但其实直接用类方法装饰器装饰视图类，传入参数name=dispatch就行了，不需要重写dispatch方法。&lt;/p&gt;&#xA;&lt;p&gt;既如上文。&lt;/p&gt;</description>
        </item><item>
            <title>为django-admin的userpermission添加read only(can view)权限</title>
            <link>http://localhost:1313/posts/2018/09/2018-09-06-%E4%B8%BAdjango-admin%E7%9A%84userpermission%E6%B7%BB%E5%8A%A0read-onlycan-view%E6%9D%83%E9%99%90/</link>
            <pubDate>Thu, 06 Sep 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/09/2018-09-06-%E4%B8%BAdjango-admin%E7%9A%84userpermission%E6%B7%BB%E5%8A%A0read-onlycan-view%E6%9D%83%E9%99%90/</guid>
            <description>&lt;p&gt;默认的django-admin中用户的models权限只有三个,分别是(Can change, Can add, Can delete),显然的,对于绝大部分crud工程师(^_^)而言,一眼看过去就少了些什么,没错,少了很关键的Can view权限.&lt;/p&gt;&#xA;&lt;p&gt;当然django-admin的用户权限是可以自定义的,需要改permission的meta,这里不细述,发现一个简单好用的django app,可以直接添加Can view权限,美滋滋.&lt;/p&gt;&#xA;&lt;p&gt;最终效果如下 &lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/wp-content/uploads/2018/09/B6CE8AA0-F925-4290-B2C0-E3C98ECF0C79.png&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;&lt;img src=&#34;images/B6CE8AA0-F925-4290-B2C0-E3C98ECF0C79.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;插件是: django-admin-view-permission 地址 &lt;a class=&#34;link&#34; href=&#34;https://github.com/ctxis/django-admin-view-permission&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/ctxis/django-admin-view-permission&lt;/a&gt; 使用方式及其简单&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#pip安装插件&#xA;pip install django-admin-view-permission&#xA;&#xA;#将app注册,记得一定注册在django.contrib.admin之前&#xA;INSTALLED_APPS = [&#xA;    &amp;#39;admin_view_permission&amp;#39;,&#xA;    &amp;#39;django.contrib.admin&amp;#39;,&#xA;    ...&#xA;]&#xA;&#xA;#更新数据库&#xA;python manage.py migrate&#xA;&#xA;即可&#xA;&#xA;#如需要只对一些数据库管用,可以&#xA;ADMIN_VIEW_PERMISSION_MODELS = [&#xA;    &amp;#39;auth.User&amp;#39;,&#xA;    ...&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;的确是个好东西啊,免掉了手写这种本应就有的权限.分享一下.&lt;/p&gt;</description>
        </item><item>
            <title>一个自解析nginx upstream和location并检测连通性的web系统</title>
            <link>http://localhost:1313/posts/2018/07/2018-07-23-%E4%B8%80%E4%B8%AA%E8%87%AA%E8%A7%A3%E6%9E%90nginx-upstream%E5%92%8Clocation%E5%B9%B6%E6%A3%80%E6%B5%8B%E8%BF%9E%E9%80%9A%E6%80%A7%E7%9A%84web%E7%B3%BB%E7%BB%9F/</link>
            <pubDate>Mon, 23 Jul 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/07/2018-07-23-%E4%B8%80%E4%B8%AA%E8%87%AA%E8%A7%A3%E6%9E%90nginx-upstream%E5%92%8Clocation%E5%B9%B6%E6%A3%80%E6%B5%8B%E8%BF%9E%E9%80%9A%E6%80%A7%E7%9A%84web%E7%B3%BB%E7%BB%9F/</guid>
            <description>&lt;p&gt;最近做的一个小web系统，主要的思路是，怎样才能将nginx集群的海量配置文件,包括server和upstream及location等完全对象化 想做的东西就类似于httpdns，将nginx的海量配置文件对象化，或者考虑能不能数据库化 现在的功能只是解析所有nginx配置文件,自动读取upstream列表和location中proxy_pass,然后做连接性追踪 当然,追踪列表也可自定义添加,在admin后台配置即可 最终效果图 &lt;img src=&#34;images/custom.png&#34; alt=&#34;custom&#34; /&gt;&#xA; &lt;img src=&#34;images/back.png&#34; alt=&#34;back&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;git地址 &lt;a class=&#34;link&#34; href=&#34;https://github.com/calmkart/check_port&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/calmkart/check_port&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#大致部署过程&#xA;pip install -r pip.text&#xA;#创建checkport数据库&#xA;#修改settings.py中的数据库配置&#xA;python manage.py makemigrations&#xA;python manage.py migrate&#xA;#安装redis,修改settings.py中的redis配置&#xA;#修改readnginx的handle.py和handle_test.py中的CONFIG_PATH以及GIT_PATH(用于自动解析和更新nginx配置)&#xA;#用supervisor启动系统&#xA;supervisord -c checkport/supervisord.conf&#xA;#此外,flower需要用nginx做转发,参考配置文件如下&#xA;location ~ ^/flower/? {&#xA;rewrite ^/flower/?(.*)$ /$1 break;&#xA;&#xA;sub_filter &amp;#39;=&amp;#34;/&amp;#39; &amp;#39;=&amp;#34;/flower/&amp;#39;;&#xA;sub_filter_last_modified on;&#xA;sub_filter_once off;&#xA;&#xA;# proxy_pass http://unix:/tmp/flower.sock:/;&#xA;proxy_pass http://xxxxxxxxxxxxxxxx;&#xA;proxy_redirect off;&#xA;proxy_set_header Host $host;&#xA;proxy_set_header Upgrade $http_upgrade;&#xA;proxy_set_header Connection &amp;#34;upgrade&amp;#34;;&#xA;proxy_http_version 1.1;&#xA;}&#xA;&#xA;其中三种常见操作为:&#xA;1.将nginx配置文件列表pull到最新&#xA;2.自动读取和解析nginx配置文件,并将获取的upstream以及proxy_pass列表写进数据库&#xA;3.探测数据库中所有需要探测的IP:PORT对象实例&#xA;&#xA;可在后台管理-&amp;gt;数据更新中手动按键更新&#xA;也可在admin后台配置Periodic tasks的celery beat定时任务&#xA;其中:&#xA;1.readnginx.tasks.git_pull_config 任务更新nginx配置文件仓库&#xA;2.pubstatus.tasks.get_status 任务获取所有IP:PORT对象状态&#xA;3.readnginx.tasks.read_nginx 任务度读取nginx配置文件并解析,更新数据库IP:PORT对象列表&#xA;可根据需求设置定时任务周期&#xA;通过flower后台可以查看任务执行情况&#xA;&#xA;自定义追踪checkport的IP:PORT列表通过admin后台添加instance即可实现&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
        </item><item>
            <title>django使用middleware实现views的访问限制</title>
            <link>http://localhost:1313/posts/2017/12/2017-12-27-django%E4%BD%BF%E7%94%A8middleware%E5%AE%9E%E7%8E%B0views%E7%9A%84%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6/</link>
            <pubDate>Wed, 27 Dec 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/12/2017-12-27-django%E4%BD%BF%E7%94%A8middleware%E5%AE%9E%E7%8E%B0views%E7%9A%84%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6/</guid>
            <description>&lt;p&gt;需要实现这样的需求，对于以个django app，需要对其中的一些restful api做IP访问限制，这样实现起来最方便的是在middleware中写逻辑。&lt;/p&gt;&#xA;&lt;p&gt;关于django中间件的说明： &lt;a class=&#34;link&#34; href=&#34;http://usyiyi.cn/translate/Django_111/topics/http/middleware.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;http://usyiyi.cn/translate/Django_111/topics/http/middleware.html&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/translate/django_182/topics/http/middleware.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;http://python.usyiyi.cn/translate/django_182/topics/http/middleware.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;在django app得middleware.py中添加如下代码&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from django.http import HttpResponse&#xA;&#xA;class checkIPMiddleware(object):&#xA;    def process_request(self, request):&#xA;        root_func = request.path.split(&amp;#34;/&amp;#34;)[1]&#xA;        api_flag = True if root_func==&amp;#34;api&amp;#34; else False&#xA;        if api_flag:&#xA;            ip = request.META.get(&amp;#34;HTTP_X_REAL_IP&amp;#34;, request.META.get(&amp;#34;REMOTE_ADDR&amp;#34;))&#xA;            if (ip==&amp;#34;10.10.10.10&amp;#34; or ip==&amp;#34;11.11.11.11&amp;#34;):&#xA;                return None&#xA;            else:&#xA;                return HttpReponse(&amp;#34;you are not allowed&amp;#34;)&#xA;        return None&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于request对象内容，详情如下(本代码限制的是所有/api/后的访问)： &lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/translate/django_182/ref/request-response.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;http://python.usyiyi.cn/translate/django_182/ref/request-response.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;关于获取用户IP，在没有反向代理的情况下可以获取http头中的REMOTE_ADDR字段，用request.META对象来获取 当有Nginx等反向代理的时候，就会获取到本机IP，所以需要在nginx反向代理时，将用户原IP记录下来写入HTTP头中 既配置nginx配置如下(/site-enable/default):&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;location .... {    &#xA;    proxy_set_header X-Real-IP $remote_addr;&#xA;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#xA;    proxy_set_header Host $http_host;&#xA;    proxy_set_header X-NginX-Proxy true;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后在settings.py中将这个class添加进去&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MIDDLEWARE_CLASSES = [&#xA;        &amp;#39;appname.middleware.checkIPMiddleware&amp;#39;&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重启django之后，则/api后的restful api只允许10.10.10.10和11.11.11.11访问，其他时候就会返回&amp;quot;you are not allowed&amp;quot;&lt;/p&gt;</description>
        </item><item>
            <title>使用zabbix api提取趋势(trend)和历史(history)数据</title>
            <link>http://localhost:1313/posts/2017/12/2017-12-27-%E4%BD%BF%E7%94%A8zabbix-api%E6%8F%90%E5%8F%96%E8%B6%8B%E5%8A%BFtrend%E5%92%8C%E5%8E%86%E5%8F%B2history%E6%95%B0%E6%8D%AE/</link>
            <pubDate>Wed, 27 Dec 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/12/2017-12-27-%E4%BD%BF%E7%94%A8zabbix-api%E6%8F%90%E5%8F%96%E8%B6%8B%E5%8A%BFtrend%E5%92%8C%E5%8E%86%E5%8F%B2history%E6%95%B0%E6%8D%AE/</guid>
            <description>&lt;p&gt;zabbix restful api说明见官网文档 &lt;a class=&#34;link&#34; href=&#34;https://www.zabbix.com/documentation/4.0/zh/manual/api/reference/apiinfo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://www.zabbix.com/documentation/4.0/zh/manual/api/reference/apiinfo&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;使用了github上封装好的python zabbix api,免去了自己造轮子的过程 &lt;a class=&#34;link&#34; href=&#34;https://github.com/lukecyca/pyzabbix&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/lukecyca/pyzabbix&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;这个封装的python zabbix api实现起来也比较简单，主要是用缺省的类__getattr__()方法，调用zabbix的restful api&lt;/p&gt;&#xA;&lt;p&gt;首先用pip安装pyzabbix&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pip install pyzabbix&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体实现获取trend和history代码如下:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#---coding:utf-8---&#xA;&#xA;from pyzabbix import ZabbixAPI&#xA;import time&#xA;class get_net(object):&#xA;&#x9;url = &amp;#34;&amp;#34;&#xA;&#x9;username = None&#xA;&#x9;password = None&#xA;&#xA;&#x9;def __init__(self, server, user, passwd):&#xA;&#x9;&#x9;self.url = &amp;#34;http://&amp;#34;+server+&amp;#34;/zabbix&amp;#34;&#xA;&#x9;&#x9;self.username = user&#xA;&#x9;&#x9;self.password = passwd&#xA;&#xA;&#x9;def get_trend(self, info_list):&#xA;&#x9;&#x9;z = ZabbixAPI(self.url)&#xA;&#x9;&#x9;z.login(self.username,self.password)&#xA;&#x9;&#x9;for info in info_list:&#xA;&#x9;&#x9;&#x9;hosts = z.host.get(filter={&amp;#34;host&amp;#34;:info[&amp;#34;ip&amp;#34;]})&#xA;&#x9;&#x9;&#x9;if hosts:&#xA;&#x9;&#x9;&#x9;&#x9;host_id = hosts[0][&amp;#34;hostid&amp;#34;]&#xA;&#x9;&#x9;&#x9;print host_id&#xA;&#x9;&#x9;&#x9;items = z.item.get(hostids=host_id,filter={&amp;#34;key_&amp;#34;:&amp;#34;ifHCOutOctets[&amp;#34;+info[&amp;#34;interface&amp;#34;]+&amp;#34;]&amp;#34;})[0]&#xA;&#x9;&#x9;&#x9;if items:&#xA;&#x9;&#x9;&#x9;&#x9;item_id = items[&amp;#34;itemid&amp;#34;]&#xA;&#x9;&#x9;&#x9;trend = z.trend.get(itemids=item_id)&#xA;&#x9;&#x9;&#x9;for td in trend:&#xA;&#x9;&#x9;&#x9;&#x9;clock = self.get_clock(td[&amp;#39;clock&amp;#39;])&#xA;&#x9;&#x9;&#x9;&#x9;if (&amp;#34;20:00&amp;#34; in clock) or (&amp;#34;21:00&amp;#34; in clock) or (&amp;#34;22:00&amp;#34; in clock):&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;print clock+&amp;#34;        &amp;#34;+str(int(td[&amp;#34;value_avg&amp;#34;])*8/1048576)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;f = open(info[&amp;#34;name&amp;#34;],&amp;#34;a&amp;#34;)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;f.write(clock+&amp;#34;        &amp;#34;+str(int(td[&amp;#34;value_avg&amp;#34;])*8/1048576))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;f.write(&amp;#34;\n&amp;#34;)&#xA;&#x9;&#x9;&#x9;f.close()&#xA;&#xA;&#x9;def get_history(self, info_list):&#xA;&#x9;&#x9;z = ZabbixAPI(self.url)&#xA;&#x9;&#x9;z.login(self.username,self.password)&#xA;&#x9;&#x9;for info in info_list:&#xA;&#x9;&#x9;&#x9;hosts = z.host.get(filter={&amp;#34;host&amp;#34;:info[&amp;#34;ip&amp;#34;]})&#xA;&#x9;&#x9;&#x9;if hosts:&#xA;&#x9;&#x9;&#x9;&#x9;host_id = hosts[0][&amp;#34;hostid&amp;#34;]&#xA;&#x9;&#x9;&#x9;print host_id&#xA;&#x9;&#x9;&#x9;items = z.item.get(hostids=host_id,filter={&amp;#34;key_&amp;#34;:&amp;#34;ifHCOutOctets[&amp;#34;+info[&amp;#34;interface&amp;#34;]+&amp;#34;]&amp;#34;})[0]&#xA;&#x9;&#x9;&#x9;if items:&#xA;&#x9;&#x9;&#x9;&#x9;item_id = items[&amp;#34;itemid&amp;#34;]&#xA;&#x9;&#x9;&#x9;history = z.history.get(itemids=item_id,time_from=1512129600)&#xA;&#x9;&#x9;&#x9;r_t = []&#xA;&#x9;&#x9;&#x9;print history&#xA;&#x9;&#x9;&#x9;for hs in history:&#xA;&#x9;&#x9;&#x9;&#x9;clock = self.get_clock(hs[&amp;#39;clock&amp;#39;])&#xA;&#x9;&#x9;&#x9;&#x9;if (&amp;#34;20:&amp;#34; in clock) or (&amp;#34;21:&amp;#34; in clock) or (&amp;#34;22:&amp;#34; in clock):&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;print clock+&amp;#34;        &amp;#34;+str(int(hs[&amp;#34;value&amp;#34;])/1048576)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;r_t.append(clock+&amp;#34;        &amp;#34;+str(int(hs[&amp;#34;value&amp;#34;])/1048576))&#xA;&#x9;&#x9;&#x9;r_t_str = &amp;#34;\n&amp;#34;.join(r_t)&#xA;&#x9;&#x9;&#x9;f = open(&amp;#34;test_history&amp;#34;,&amp;#34;a&amp;#34;)&#xA;&#x9;&#x9;&#x9;f.write(r_t_str)&#xA;&#x9;&#x9;&#x9;f.close()&#xA;&#x9;&#xA;&#x9;def get_clock(self, value):&#xA;&#x9;&#x9;clock = time.localtime(int(value))&#xA;&#x9;&#x9;format = &amp;#39;%Y-%m-%d %H:%M&amp;#39;&#xA;&#x9;&#x9;return time.strftime(format,clock)&#xA;&#xA;#test = get_net(&amp;#34;zabbix服务器IP&amp;#34;, &amp;#34;user&amp;#34;, &amp;#34;pass&amp;#34;)&#xA;#test.get_trend([{&amp;#34;ip&amp;#34;:&amp;#34;机器IP&amp;#34;,&amp;#34;name&amp;#34;:&amp;#34;某机器&amp;#34;,&amp;#34;interface&amp;#34;:&amp;#34;某接口名&amp;#34;}])&#xA;#test.get_trend(info列表，格式如上)&#xA;#test.get_history([{&amp;#34;ip&amp;#34;:&amp;#34;机器IP&amp;#34;,&amp;#34;name&amp;#34;:&amp;#34;某机器&amp;#34;,&amp;#34;interface&amp;#34;:&amp;#34;某接口名&amp;#34;}])&#xA;#test.get_history(info列表，格式如上)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注： 其中get_clock()函数用于做linux时间戳转换。&lt;/p&gt;</description>
        </item></channel>
</rss>
