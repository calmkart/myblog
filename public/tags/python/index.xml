<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Python on cAlm的个人Blog</title>
        <link>http://localhost:1313/tags/python/</link>
        <description>Recent content in Python on cAlm的个人Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 30 Oct 2019 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/python/index.xml" rel="self" type="application/rss+xml" /><item>
            <title>python利用零宽切片插入元素</title>
            <link>http://localhost:1313/posts/2019/10/2019-10-30-python%E5%88%A9%E7%94%A8%E9%9B%B6%E5%AE%BD%E5%88%87%E7%89%87%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0/</link>
            <pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2019/10/2019-10-30-python%E5%88%A9%E7%94%A8%E9%9B%B6%E5%AE%BD%E5%88%87%E7%89%87%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0/</guid>
            <description>&lt;p&gt;常见的python插入元素方式一般是insert或者手动挪动后修改值,然后其实还有种比较少用的通过零宽切片插入元素的方式,比较有意思,随便记录下.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Python 3.8.0 (v3.8.0:fa919fdf25, Oct 14 2019, 10:23:27) &#xA;[Clang 6.0 (clang-600.0.57)] on darwin&#xA;Type &amp;#34;help&amp;#34;, &amp;#34;copyright&amp;#34;, &amp;#34;credits&amp;#34; or &amp;#34;license&amp;#34; for more information.&#xA;&amp;gt;&amp;gt;&amp;gt; a = [1,2,3,4,5]&#xA;&amp;gt;&amp;gt;&amp;gt; a[:0] = [0,0,0]&#xA;&amp;gt;&amp;gt;&amp;gt; a&#xA;[0, 0, 0, 1, 2, 3, 4, 5]&#xA;&amp;gt;&amp;gt;&amp;gt; a[4:4] = [8,8,8,8,8,8]&#xA;&amp;gt;&amp;gt;&amp;gt; a&#xA;[0, 0, 0, 1, 8, 8, 8, 8, 8, 8, 2, 3, 4, 5]&#xA;&amp;gt;&amp;gt;&amp;gt; a[4:8] = []&#xA;&amp;gt;&amp;gt;&amp;gt; a&#xA;[0, 0, 0, 1, 8, 8, 2, 3, 4, 5]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;无正文.&lt;/p&gt;&#xA;</description>
        </item><item>
            <title>Django sso server(一个用户友好的的单点登录系统)</title>
            <link>http://localhost:1313/posts/2018/09/2018-09-28-django-sso-server%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E5%8F%8B%E5%A5%BD%E7%9A%84%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F/</link>
            <pubDate>Fri, 28 Sep 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/09/2018-09-28-django-sso-server%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E5%8F%8B%E5%A5%BD%E7%9A%84%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F/</guid>
            <description>&lt;p&gt;最近写了一个单点登录系统,这里做一些总结.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/wp-content/uploads/2018/09/5C45207A-AF09-475D-ACD6-E732CFE1596D.png&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;&lt;img src=&#34;images/5C45207A-AF09-475D-ACD6-E732CFE1596D.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/a&gt; github地址:(欢迎来star一发^_^) &lt;a class=&#34;link&#34; href=&#34;https://github.com/calmkart/Django-sso-server&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/calmkart/Django-sso-server&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;1流程原理&#34;&gt;1.流程原理&#xA;&lt;/h3&gt;&lt;h4 id=&#34;1系统管理流程&#34;&gt;&amp;lt;1&amp;gt;.系统管理流程&#xA;&lt;/h4&gt;&lt;p&gt;管理员在初始化系统时，填写ldap相关设置以及管理员账号相关设置，之后管理员账号可以在管理员后台调整相关配置 其中: a.系统初始化时将自动生成rsa公私钥,系统中所有涉及的密码,都会经过aes加密存放在数据库中,包括rsa私钥也会经过aes加密存放 b.在取用密码时将调用aes解密,加密的salt写在了common/crypto.py中,也可以自己替换&lt;/p&gt;&#xA;&lt;h4 id=&#34;2用户流程&#34;&gt;&amp;lt;2&amp;gt;.用户流程&#xA;&lt;/h4&gt;&lt;p&gt;用户登录sso系统，验证ldap账号成功后，将用户信息以&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;now = time.time()&#xA;user_info = &amp;#34;{0}|||||{1}&amp;#34;.format(ldap_username, now)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;的形式,通过rsa公钥加密写入cookie中，key为sso_user&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;response.set_cookie(&amp;#39;sso_user&amp;#39;, rsa.crypto(&#xA;                public_key, user_info), domain=options.objects.all()[0].cookie_domain)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他需要接入sso系统的子系统可以通过sso系统的api，来判断用户是否可以登录&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;url:      /api/auth&#xA;method:   POST&#xA;post_json_data:  {&amp;#34;sso_user&amp;#34;:cookie}&#xA;return:     {&amp;#34;status&amp;#34;:True/False, &amp;#34;msg&amp;#34;:username}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本sso系统已提供了相关装饰器，可在管理后台-添加站点的帮助栏查看&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import requests&#xA;&#xA;def auth_login(func):&#xA;&amp;#39;&amp;#39;&amp;#39;&#xA;装饰器,用于需要登录的views functions,将读取cookie并调用sso的api获取username&#xA;&#xA;也可手动编写相关装饰器&#xA;sso系统的登录鉴权api为&amp;#34;http://sso域名/api/auth&amp;#34;(如&amp;#34;http://sso.calmkart.com/api/auth&amp;#34;)&#xA;用POST方法以json形式将sso_cookie传给上述api,&#xA;返回{&amp;#34;status&amp;#34;:True, &amp;#34;msg&amp;#34;:{username}}则登录成功&#xA;否则{&amp;#34;status&amp;#34;:False, &amp;#34;msg&amp;#34;:{exception}}则登录失败&#xA;&#xA;&amp;#39;&amp;#39;&amp;#39;&#xA;    def _auth(request):&#xA;        cookie = request.COOKIES.get(&amp;#34;sso_user&amp;#34;, &amp;#34;&amp;#34;)&#xA;        if cookie==&amp;#34;&amp;#34;:&#xA;            return HttpResponseRedirect(&amp;#34;{http://sso站域名/}&amp;#34;)&#xA;        r = request.post(&amp;#34;{http://sso站域名/api/auth}&amp;#34;,data={&amp;#34;sso_cookie&amp;#34;:cookie})&#xA;        if r.json()[&amp;#34;status&amp;#34;]==False:&#xA;            return HttpResponseRedirect(&amp;#34;{http://sso站域名}&amp;#34;)&#xA;        else:&#xA;            username = r.json()[&amp;#34;msg&amp;#34;]&#xA;            if username == &amp;#34;&amp;#34; or username == &amp;#34;error&amp;#34;:&#xA;                return HttpResponseRedirect(&amp;#34;{http://sso站域名/}&amp;#34;)&#xA;            else:&#xA;                return func(request, username)&#xA;    return _auth&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用户拥有cookie后登陆系统，系统将解cookie，并获取当前时间，若时间不超过最大时间，则返回username&lt;/p&gt;&#xA;&lt;h4 id=&#34;3企业扫码登陆流程&#34;&gt;&amp;lt;3&amp;gt;.企业扫码登陆流程&#xA;&lt;/h4&gt;&lt;p&gt;在管理后台配置企业微信扫码登陆相关参数，通过企业微信相关js api，生成二维码，用户扫码后，企业微信后台将用户请求重定向到/api/wxlogin  (method:get)上，并加上携带有用户username信息的code参数，成功则写cookie。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h3 id=&#34;2common相关模块原理&#34;&gt;2.common相关模块原理&#xA;&lt;/h3&gt;&lt;p&gt;参见本blog其他博文&lt;/p&gt;&#xA;&lt;h4 id=&#34;1关于django的图片验证码&#34;&gt;&amp;lt;1&amp;gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=332&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;关于django的图片验证码&lt;/a&gt;&#xA;&lt;/h4&gt;&lt;h4 id=&#34;2关于python操作ldap&#34;&gt;&amp;lt;2&amp;gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=355&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;关于python操作ldap&lt;/a&gt;&#xA;&lt;/h4&gt;&lt;h4 id=&#34;3关于python操作rsaaes加解密&#34;&gt;&amp;lt;3&amp;gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=353&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;关于python操作rsa,aes加解密&lt;/a&gt;&#xA;&lt;/h4&gt;</description>
        </item><item>
            <title>python操作ldap</title>
            <link>http://localhost:1313/posts/2018/09/2018-09-28-python%E6%93%8D%E4%BD%9Cldap/</link>
            <pubDate>Fri, 28 Sep 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/09/2018-09-28-python%E6%93%8D%E4%BD%9Cldap/</guid>
            <description>&lt;p&gt;封装了一个python的ldap常用操作类&lt;/p&gt;&#xA;&lt;p&gt;首先pip装库&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pip install python-ldap&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后开始代码部分&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# -*- coding:utf-8 -*-&#xA;from __future__ import absolute_import&#xA;&#xA;import binascii&#xA;import hashlib&#xA;from base64 import b64encode&#xA;&#xA;import ldap&#xA;import ldap.modlist as modlist&#xA;&#xA;from common.common import log&#xA;&#xA;class MyLdap():&#xA;     &#xA;    def __init__(self,ldap_host=None,base_dn=None,user=None,password=None):&#xA;        self.base_dn = base_dn&#xA;        self.ldap_host = ldap_host&#xA;        self.user = user&#xA;        self.password = password&#xA;        try:&#xA;            self.ldapconn = ldap.initialize(ldap_host)&#xA;            self.ldapconn.simple_bind(user,password)&#xA;        except ldap.LDAPError,e:&#xA;            log().error(str(e))&#xA;            print e&#xA;&#xA;    @property&#xA;    def status(self):&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        验证初始化ldap账号密码,以及ldap地址是否正确&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        ldap_client = ldap.initialize(self.ldap_host)&#xA;        try:&#xA;            ldap_client.simple_bind_s(self.user, self.password)&#xA;            ldap_client.unbind_s()&#xA;            return {&amp;#34;status&amp;#34;:True}&#xA;        except Exception as e:&#xA;            log().error(str(e))&#xA;            return {&amp;#34;status&amp;#34;:False, &amp;#34;msg&amp;#34;:&amp;#34;ldap初始化管理员账号密码或ldap地址有误,详情:{0}&amp;#34;.format(str(e))}&#xA;&#xA;    def _ldap_search_dn(self,uid=None):&#xA;        obj = self.ldapconn&#xA;        obj.protocal_version = ldap.VERSION3&#xA;        searchScope = ldap.SCOPE_SUBTREE&#xA;        retrieveAttributes = None &#xA;        searchFilter = &amp;#34;cn=&amp;#34; + uid&#xA;        &#xA;        try:&#xA;            ldap_result_id = obj.search(self.base_dn, searchScope, searchFilter, retrieveAttributes)&#xA;            result_type, result_data = obj.result(ldap_result_id, 0)&#xA;            if result_type == ldap.RES_SEARCH_ENTRY:&#xA;                return result_data[0][0]&#xA;            else:&#xA;                return None&#xA;        except ldap.LDAPError, e:&#xA;            log().error(str(e))&#xA;&#xA;    def ldap_get_user(self,uid=None):&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        获取ldap用户详情,失败返None&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        obj = self.ldapconn&#xA;        obj.protocal_version = ldap.VERSION3&#xA;        searchScope = ldap.SCOPE_SUBTREE&#xA;        retrieveAttributes = None &#xA;        searchFilter = &amp;#34;cn=&amp;#34; + uid&#xA;        try:&#xA;            ldap_result_id = obj.search(self.base_dn, searchScope, searchFilter, retrieveAttributes)&#xA;            result_type, result_data = obj.result(ldap_result_id, 0)&#xA;            if result_type == ldap.RES_SEARCH_ENTRY:&#xA;                username = result_data[0][1][&amp;#39;cn&amp;#39;][0]&#xA;                mail = result_data[0][1][&amp;#39;mail&amp;#39;][0]&#xA;                displayName = result_data[0][1][&amp;#39;displayName&amp;#39;][0]&#xA;                sn = result_data[0][1][&amp;#39;sn&amp;#39;][0]&#xA;                result = {&amp;#39;username&amp;#39;:username,&amp;#39;mail&amp;#39;:mail,&amp;#39;displayName&amp;#39;:displayName, &amp;#39;sn&amp;#39;:sn}&#xA;                return result&#xA;            else:&#xA;                return None&#xA;        except ldap.LDAPError, e:&#xA;            log().error(str(e))&#xA;    &#xA;    def ldap_get(self,uid=None,passwd=None):&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        验证ldap账号密码,成功返True,失败返False&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        target_cn = self._ldap_search_dn(uid)&#xA;        if not target_cn:&#xA;            return False   &#xA;        try:&#xA;            client = ldap.initialize(self.ldap_host)&#xA;            client.simple_bind_s(target_cn,passwd)&#xA;            client.unbind_s()&#xA;            return True&#xA;        except ldap.LDAPError,e:&#xA;            log().error(str(e))&#xA;            return False&#xA;&#xA;    &#xA;    def cnupdatepass(self, cn, passwd):&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        更改ldap密码,成功返True,失败返error&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        dn=&amp;#39;cn={0},{1}&amp;#39;.format(cn, self.base_dn)&#xA;        try:&#xA;            result=self.ldapconn.search_s(dn, ldap.SCOPE_SUBTREE, &amp;#39;cn=%s&amp;#39; % cn)&#xA;            oldpass=result[0][1][&amp;#39;userPassword&amp;#39;]&#xA;            oldwifipass=result[0][1][&amp;#39;sambaNTPassword&amp;#39;]&#xA;            newpass=&amp;#39;{MD5}&amp;#39; + b64encode(hashlib.md5(passwd).digest())&#xA;            wifipass=binascii.hexlify(hashlib.new(&amp;#39;md4&amp;#39;, passwd.encode(&amp;#39;utf-16le&amp;#39;)).digest())&#xA;            old={&amp;#39;userPassword&amp;#39;:oldpass,&amp;#39;sambaNTPassword&amp;#39;: oldwifipass}&#xA;            new={&amp;#34;sambaNTPassword&amp;#34;: [wifipass],&amp;#34;userPassword&amp;#34;:[newpass]}&#xA;            mlist = modlist.modifyModlist(old, new)&#xA;            self.ldapconn.modify_s(dn, mlist)&#xA;            return {&amp;#34;status&amp;#34;:True}&#xA;        except ldap.LDAPError as e:&#xA;            log().error(str(e))&#xA;            return {&amp;#34;status&amp;#34;:False, &amp;#34;msg&amp;#34;:&amp;#34;ldap更改密码错误,详情: {0}&amp;#34;.format(str(e))}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用时&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ldap_client = MyLdap(ldap_url, base_dn, admin, password)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码注释已经写的很清楚了感觉,不再写详情了,本文做个备忘&lt;/p&gt;</description>
        </item><item>
            <title>python操作rsa和aes加解密</title>
            <link>http://localhost:1313/posts/2018/09/2018-09-28-python%E6%93%8D%E4%BD%9Crsa%E5%92%8Caes%E5%8A%A0%E8%A7%A3%E5%AF%86/</link>
            <pubDate>Fri, 28 Sep 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/09/2018-09-28-python%E6%93%8D%E4%BD%9Crsa%E5%92%8Caes%E5%8A%A0%E8%A7%A3%E5%AF%86/</guid>
            <description>&lt;p&gt;封装了一个python的操作rsa和aes的加解密类&lt;/p&gt;&#xA;&lt;p&gt;首先pip装库&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pip install pycrypto&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后代码如下&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# -*- coding:utf-8 -*-&#xA;import base64&#xA;from Crypto import Random&#xA;from Crypto.Hash import SHA&#xA;from Crypto.Cipher import PKCS1_v1_5 as Cipher_pkcs1_v1_5&#xA;from Crypto.Signature import PKCS1_v1_5 as Signature_pkcs1_v1_5&#xA;from Crypto.PublicKey import RSA&#xA;from Crypto.Cipher import AES&#xA;from binascii import b2a_hex, a2b_hex&#xA;&#xA;#AES加解密,用于本地加密数据库密码和rsa private key&#xA;aes_salt = &amp;#34;opquweoijuqowieh&amp;#34;&#xA;class Aes():&#xA;    &#xA;    def __init__(self, key=aes_salt):&#xA;        self.key = key&#xA;        self.mode = AES.MODE_CBC&#xA;&#xA;    def encrypt(self, text):&#xA;        cryptor = AES.new(self.key, self.mode, b&amp;#39;0000000000000000&amp;#39;)&#xA;        length = 16&#xA;        count = len(text)&#xA;        if count &amp;lt; length: add = (length-count) text = text + (&amp;#39;\0&amp;#39; * add) elif count &amp;gt; length:&#xA;            add = (length-(count % length))&#xA;            text = text + (&amp;#39;\0&amp;#39; * add)&#xA;        self.ciphertext = cryptor.encrypt(text)&#xA;        return b2a_hex(self.ciphertext)&#xA;&#xA;    def decrypt(self, text):&#xA;        cryptor = AES.new(self.key, self.mode, b&amp;#39;0000000000000000&amp;#39;)&#xA;        plain_text = cryptor.decrypt(a2b_hex(text))&#xA;        return plain_text.rstrip(&amp;#39;\0&amp;#39;)&#xA;&#xA;#rsa加解密,用于cookie的加解密&#xA;class Rsa():&#xA;    &#xA;    def __init__(self):&#xA;        self.random_generator = Random.new().read&#xA;&#xA;    def gen_rsa_keys(self):&#xA;        rsa = RSA.generate(1024, self.random_generator)&#xA;        private_pem = rsa.exportKey()&#xA;        public_pem = rsa.publickey().exportKey()&#xA;        return (private_pem, public_pem)&#xA;&#xA;    def crypto(self, public_key, text):&#xA;        rsakey = RSA.importKey(public_key)&#xA;        cipher = Cipher_pkcs1_v1_5.new(rsakey)&#xA;        crypto_text = base64.b64encode(cipher.encrypt(text))&#xA;        return crypto_text&#xA;&#xA;    def decrypt(self, private_key, text):&#xA;        rsakey = RSA.importKey(private_key)&#xA;        cipher = Cipher_pkcs1_v1_5.new(rsakey)&#xA;        decrypt_text = cipher.decrypt(base64.b64decode(&#xA;            text), self.random_generator)&#xA;        return decrypt_text&#xA;&#xA;if __name__ == &amp;#39;__main__&amp;#39;:&#xA;    rsa = Rsa()&#xA;    aes = Aes()&#xA;    (pri,pub)=rsa.gen_rsa_keys()&#xA;    jm = rsa.crypto(pub, &amp;#34;pengng|||||123908123.123123&amp;#34;)&#xA;    print rsa.decrypt(pri, jm)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用方法&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;rsa = Rsa()&#xA;aes = Aes()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码注释写得非常详细，细节就不赘述了，做个备忘&lt;/p&gt;</description>
        </item><item>
            <title>django类视图装饰器</title>
            <link>http://localhost:1313/posts/2018/09/2018-09-18-django%E7%B1%BB%E8%A7%86%E5%9B%BE%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
            <pubDate>Tue, 18 Sep 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/09/2018-09-18-django%E7%B1%BB%E8%A7%86%E5%9B%BE%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
            <description>&lt;p&gt;一点关于django类视图装饰器的小笔记。&lt;/p&gt;&#xA;&lt;p&gt;django类视图是很常用的，对于传统的函数视图来说，装饰器可以直接装饰函数，但类视图，装饰器无法直接装饰类方法。&lt;/p&gt;&#xA;&lt;p&gt;比较了几种常见的解决方法,个人觉得比较优雅的解决方法如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from django.shortcuts import render&#xA;from django.utils.decorators import method_decorator&#xA;from django.views.decorators.csrf import csrf_exempt&#xA;from django.views.generic import View&#xA;&#xA;@method_decorator(csrf_exempt, name=&amp;#34;dispatch&amp;#34;)&#xA;class login(View):&#xA;&#xA;    @method_decorator(auth_login)&#xA;    def get(self, request, username):&#xA;        #....func...&#xA;        return render(request, &amp;#39;login.html&amp;#39;, {&amp;#34;displayName&amp;#34;:username, &amp;#34;admin_flag&amp;#34;:admin_flag})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;既如以上代码，将装饰器函数传给method_decorator方法，直接修饰视图类方法。&lt;/p&gt;&#xA;&lt;p&gt;也可直接修饰视图类，对于需要修饰的方法，用name参数的形式传入method_decorator中即可，但感觉不够优雅。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from django.shortcuts import render&#xA;from django.utils.decorators import method_decorator&#xA;from django.views.decorators.csrf import csrf_exempt&#xA;from django.views.generic import View&#xA;&#xA;@method_decorator(csrf_exempt, name=&amp;#34;dispatch&amp;#34;)&#xA;@method_decorator(auth_login, name=&amp;#34;get&amp;#34;)&#xA;class login(View):&#xA;&#xA;    def get(self, request, username):&#xA;        #....func...&#xA;        return render(request, &amp;#39;login.html&amp;#39;, {&amp;#34;displayName&amp;#34;:username, &amp;#34;admin_flag&amp;#34;:admin_flag})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要稍微注意的是，csrf_exempt跨站排除装饰器，只能修饰在类视图的dispatch方法上，既原始写法如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class login(View):&#xA;    &#xA;    @method_decorator(csrf_exempt)&#xA;    def dispatch(self, request, *args, **kwargs):&#xA;        return super(login,self).dispatch(request,*args,**kwargs)&#xA;    &#xA;    def get(self, request, username):&#xA;        #....func...&#xA;        return render(request, &amp;#39;login.html&amp;#39;, {&amp;#34;displayName&amp;#34;:username, &amp;#34;admin_flag&amp;#34;:admin_flag})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但其实直接用类方法装饰器装饰视图类，传入参数name=dispatch就行了，不需要重写dispatch方法。&lt;/p&gt;&#xA;&lt;p&gt;既如上文。&lt;/p&gt;</description>
        </item><item>
            <title>django使用middleware实现views的访问限制</title>
            <link>http://localhost:1313/posts/2017/12/2017-12-27-django%E4%BD%BF%E7%94%A8middleware%E5%AE%9E%E7%8E%B0views%E7%9A%84%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6/</link>
            <pubDate>Wed, 27 Dec 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/12/2017-12-27-django%E4%BD%BF%E7%94%A8middleware%E5%AE%9E%E7%8E%B0views%E7%9A%84%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6/</guid>
            <description>&lt;p&gt;需要实现这样的需求，对于以个django app，需要对其中的一些restful api做IP访问限制，这样实现起来最方便的是在middleware中写逻辑。&lt;/p&gt;&#xA;&lt;p&gt;关于django中间件的说明： &lt;a class=&#34;link&#34; href=&#34;http://usyiyi.cn/translate/Django_111/topics/http/middleware.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;http://usyiyi.cn/translate/Django_111/topics/http/middleware.html&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/translate/django_182/topics/http/middleware.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;http://python.usyiyi.cn/translate/django_182/topics/http/middleware.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;在django app得middleware.py中添加如下代码&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from django.http import HttpResponse&#xA;&#xA;class checkIPMiddleware(object):&#xA;    def process_request(self, request):&#xA;        root_func = request.path.split(&amp;#34;/&amp;#34;)[1]&#xA;        api_flag = True if root_func==&amp;#34;api&amp;#34; else False&#xA;        if api_flag:&#xA;            ip = request.META.get(&amp;#34;HTTP_X_REAL_IP&amp;#34;, request.META.get(&amp;#34;REMOTE_ADDR&amp;#34;))&#xA;            if (ip==&amp;#34;10.10.10.10&amp;#34; or ip==&amp;#34;11.11.11.11&amp;#34;):&#xA;                return None&#xA;            else:&#xA;                return HttpReponse(&amp;#34;you are not allowed&amp;#34;)&#xA;        return None&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于request对象内容，详情如下(本代码限制的是所有/api/后的访问)： &lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/translate/django_182/ref/request-response.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;http://python.usyiyi.cn/translate/django_182/ref/request-response.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;关于获取用户IP，在没有反向代理的情况下可以获取http头中的REMOTE_ADDR字段，用request.META对象来获取 当有Nginx等反向代理的时候，就会获取到本机IP，所以需要在nginx反向代理时，将用户原IP记录下来写入HTTP头中 既配置nginx配置如下(/site-enable/default):&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;location .... {    &#xA;    proxy_set_header X-Real-IP $remote_addr;&#xA;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#xA;    proxy_set_header Host $http_host;&#xA;    proxy_set_header X-NginX-Proxy true;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后在settings.py中将这个class添加进去&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MIDDLEWARE_CLASSES = [&#xA;        &amp;#39;appname.middleware.checkIPMiddleware&amp;#39;&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重启django之后，则/api后的restful api只允许10.10.10.10和11.11.11.11访问，其他时候就会返回&amp;quot;you are not allowed&amp;quot;&lt;/p&gt;</description>
        </item><item>
            <title>《Python进阶》读书笔记(3)</title>
            <link>http://localhost:1313/posts/2017/11/2017-11-16-python%E8%BF%9B%E9%98%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03/</link>
            <pubDate>Thu, 16 Nov 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/11/2017-11-16-python%E8%BF%9B%E9%98%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03/</guid>
            <description>&lt;h4 id=&#34;16异常处理&#34;&gt;16.异常处理&#xA;&lt;/h4&gt;&lt;p&gt;捕获所有异常：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;except Exception as e:&#xA;    print e&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;try/except/finally语句:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;try:&#xA;    #首先执行&#xA;    pass&#xA;except:&#xA;    #异常的话执行&#xA;    pass&#xA;finally:&#xA;    #无论是否异常，在最后都执行&#xA;    pass&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;try/else语句：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;try:&#xA;    #首先执行&#xA;    pass&#xA;else:&#xA;    #异常的话执行,且不被捕获异常&#xA;    pass&#xA;finally:&#xA;    #无论是否异常，在最后都执行&#xA;    pass&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;17简易webserver&#34;&gt;17.简易webserver&#xA;&lt;/h4&gt;&lt;p&gt;python2:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;python -m SimpleHTTPServer 8888&#xA;#在当前文件夹建立简易http服务器，端口为8888&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;python3:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;python -m http.server 8888&#xA;#在当前文件夹建立简易http服务器，端口为8888&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，在python2中SimpleHTTPServer是处理GET和HEAD请求的，而CGIHTTPServer处理POST请求。&lt;/p&gt;&#xA;&lt;h4 id=&#34;18pprint&#34;&gt;18.pprint&#xA;&lt;/h4&gt;&lt;p&gt;可以用于打印dict等数据结构，比较漂亮&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from pprint import pprint&#xA;    pprint({a:1,b:2})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;19forelse从句&#34;&gt;19.for/else从句&#xA;&lt;/h4&gt;&lt;p&gt;else仅在for循环正常结束时才会执行，当for循环被break时，不执行else&lt;/p&gt;&#xA;&lt;p&gt;举例说明：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for item in container:&#xA;    if search_something(item):&#xA;        # Found it!&#xA;        process(item)&#xA;        break&#xA;else:&#xA;    # Didn&amp;#39;t find anything..&#xA;    not_found_in_container()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;20用with块自动释放句柄&#34;&gt;20.用with块自动释放句柄&#xA;&lt;/h4&gt;&lt;p&gt;with块可在有异常时，自动释放句柄&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;with open(&amp;#39;a.txt&amp;#39;,&amp;#39;r+&amp;#39;) as f:&#xA;#打开成功才会获得句柄，有异常则自动释放&#xA;    file = f.read()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用io.open可制定编码方式：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import io &#xA;with io.open(&amp;#39;a.txt&amp;#39;, &amp;#39;w&amp;#39;, encoding=&amp;#39;utf-8&amp;#39;) as f:&#xA;    f.write(.......)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而直接使用open(),do,close()的方式，可能因为各种error而导致没有释放资源。&lt;/p&gt;&#xA;&lt;h4 id=&#34;21协程&#34;&gt;21.协程&#xA;&lt;/h4&gt;&lt;p&gt;与生成器有点像，但生成器是返回可迭代对象的生产者，而携程是接受参数的消费者。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;def grep(pattern):&#xA;    print(&amp;#34;Searching for&amp;#34;, pattern)&#xA;    while True:&#xA;        line = (yield)&#xA;        if pattern in line:&#xA;            print(line)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们通过send方法传送给协程数据，然后用close()方法来关闭&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;search = grep(&amp;#39;coroutine&amp;#39;)&#xA;next(search)&#xA;#output: Searching for coroutine&#xA;search.send(&amp;#34;I love you&amp;#34;)&#xA;search.send(&amp;#34;Don&amp;#39;t you love me?&amp;#34;)&#xA;search.send(&amp;#34;I love coroutine instead!&amp;#34;)&#xA;#output: I love coroutine instead!&#xA;search = grep(&amp;#39;coroutine&amp;#39;)&#xA;search.close()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=124&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;《Python进阶》读书笔记(1)&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=139&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;《Python进阶》读书笔记(2)&lt;/a&gt;&lt;/p&gt;</description>
        </item><item>
            <title>《Python进阶》读书笔记(1)</title>
            <link>http://localhost:1313/posts/2017/11/2017-11-15-python%E8%BF%9B%E9%98%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/</link>
            <pubDate>Wed, 15 Nov 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/11/2017-11-15-python%E8%BF%9B%E9%98%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/</guid>
            <description>&lt;h4 id=&#34;1args与kwargs传参不定长传参&#34;&gt;&lt;strong&gt;1.*args与**kwargs传参(不定长传参)&lt;/strong&gt;&#xA;&lt;/h4&gt;&lt;p&gt;其中*args是列表传参,**kwargs是字典传参&lt;/p&gt;&#xA;&lt;p&gt;使用举例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;function(fargs, *args, **kwargs)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以用function(1)，function([1,2])，function({a:1})调用函数，都没问题。&lt;/p&gt;&#xA;&lt;h4 id=&#34;2生成器yield&#34;&gt;&lt;strong&gt;2.生成器yield&lt;/strong&gt;&#xA;&lt;/h4&gt;&lt;p&gt;可理解为只能被迭代一次的迭代器，可以节省内存&lt;/p&gt;&#xA;&lt;p&gt;使用举例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;def generation_function():&#xA;    for i in range(10):&#xA;        yield i&#xA;&#xA;for item in generation_function():&#xA;#generation_function是生成器，可被迭代的&#xA;    print item&#xA;#输出是0-&amp;gt;9，但并不需要建立一个list，节省了内存&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;3匿名函数&#34;&gt;&lt;strong&gt;3.匿名函数&lt;/strong&gt;&#xA;&lt;/h4&gt;&lt;p&gt;lambda，可减少无需重复函数&lt;/p&gt;&#xA;&lt;p&gt;格式：lambda 参数:操作&lt;/p&gt;&#xA;&lt;p&gt;使用举例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;lambda x : x+1&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;4map&#34;&gt;&lt;strong&gt;4.map()&lt;/strong&gt;&#xA;&lt;/h4&gt;&lt;p&gt;将function应用于后面参数的所有LIST元素中，返回结果。(python2返回list,python3返回迭代器)&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;map(function, list)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也支持多参数:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;map(function, list1, list2, list3....)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;常结合lambda匿名函数一起使用&lt;/p&gt;&#xA;&lt;p&gt;使用举例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;items=[1,2,3,4,5]&#xA;print map(lambda x : x**2, items)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出[1,4,9,16,25]&lt;/p&gt;&#xA;&lt;p&gt;map的本质既将一个函数映射到若干列表的所有元素上。&lt;/p&gt;&#xA;&lt;h4 id=&#34;5filter&#34;&gt;5.filter()&#xA;&lt;/h4&gt;&lt;p&gt;过滤list中的元素，返回符合条件元素的list&lt;/p&gt;&#xA;&lt;p&gt;使用举例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;number_list = range(-5,5)&#xA;less_than_zero = filter(lambda x : x&amp;lt;0, number_list)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出[-5,-4,-3,-2,-1]&lt;/p&gt;&#xA;&lt;h4 id=&#34;6reduce&#34;&gt;6.reduce()&#xA;&lt;/h4&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from functools import reduce)&#xA;product = reduce((lambda x,y:x*y),[1,2,3,4])&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出24&lt;/p&gt;&#xA;&lt;h4 id=&#34;7set&#34;&gt;7.set&#xA;&lt;/h4&gt;&lt;p&gt;集合既不能包含重复值(其他行为与list相似)&lt;/p&gt;&#xA;&lt;p&gt;语法：set(list)&lt;/p&gt;&#xA;&lt;p&gt;交集：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print (set1.intersection(set2))&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;差集：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print (set1.difference(set2))&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;8三元运算符&#34;&gt;8.三元运算符&#xA;&lt;/h4&gt;&lt;p&gt;使用举例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;is_fat = True&#xA;state = &amp;#34;fat&amp;#34; if is_fat else &amp;#34;not fat&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=139&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;《Python进阶》读书笔记(2)&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=150&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;《Python进阶》读书笔记(3)&lt;/a&gt;&lt;/p&gt;</description>
        </item><item>
            <title>《Python进阶》读书笔记(2)</title>
            <link>http://localhost:1313/posts/2017/11/2017-11-15-python%E8%BF%9B%E9%98%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02/</link>
            <pubDate>Wed, 15 Nov 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/11/2017-11-15-python%E8%BF%9B%E9%98%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02/</guid>
            <description>&lt;h4 id=&#34;9装饰器&#34;&gt;9.装饰器&#xA;&lt;/h4&gt;&lt;p&gt;既将函数传参给装饰器函数，在函数执行的上下文作某些通用操作。&lt;/p&gt;&#xA;&lt;p&gt;记得要用@wraps复制函数名称(__name__)，等等属性&lt;/p&gt;&#xA;&lt;p&gt;使用举例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from functools import wraps&#xA;&#xA;def requires_auth(f):&#xA;    @wraps(f)&#xA;    def decorated(*args, **kwargs):&#xA;        auth = request.authorization&#xA;        if not auth or not check_auth(auth.username, auth.password):&#xA;            #若未登录，返回401&#xA;            authenticate()&#xA;        return f(*args, **kwargs)&#xA;    return decorated&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;10可变数据类型和不可变数据类型&#34;&gt;10.可变数据类型和不可变数据类型&#xA;&lt;/h4&gt;&lt;p&gt;可变数据类型：list,dict&lt;/p&gt;&#xA;&lt;p&gt;不可变数据类型：int,float,string,tuple&lt;/p&gt;&#xA;&lt;p&gt;可变不可变，指的是变量指向的值：可变，就是说可以改变指向的值而地址不变。不可变，就是说改变变量的值必然改变地址。&lt;/p&gt;&#xA;&lt;p&gt;python中的赋值(=)，就是左侧得到右侧内存的引用。&lt;/p&gt;&#xA;&lt;p&gt;举例说明：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a = [1]&#xA;print a  #----&amp;gt;[1]&#xA;b = a&#xA;b.append(2)&#xA;print a #-----&amp;gt;[1,2]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为list为可变数据类型，而a和b指向同一片内存。当对b做+=操作时，只是向后扩充内存内容，而不会修改内存位置。所以a也改变了。&lt;/p&gt;&#xA;&lt;p&gt;同时要注意，python函数被定义时，默认参数只会被计算一次，不会每次都计算。所以，默认参数最好不要用可变数据类型，就算要用，也要注意在之后不要对其做修改。&lt;/p&gt;&#xA;&lt;h4 id=&#34;11__slots__&#34;&gt;11.__slots__&#xA;&lt;/h4&gt;&lt;p&gt;在类的定义中使用__slots__=[&amp;ldquo;name&amp;rdquo;,&amp;ldquo;age&amp;rdquo;]，则只有__slots__这个set中的属性可以被分配内存，不在其中的不可被分配内存。&lt;/p&gt;&#xA;&lt;h4 id=&#34;12容器collections&#34;&gt;12.容器collections&#xA;&lt;/h4&gt;&lt;p&gt;1.defaultdict&lt;/p&gt;&#xA;&lt;p&gt;调用不存在的key时，会用默认的工厂方法作为key默认值.&lt;/p&gt;&#xA;&lt;p&gt;举例说明：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from collections import defaultdic&#xA;&#xA;favourite_colors = defaultdict(list)&#xA;for name,color in colors:&#xA;    favourite_colors[name].append(color)&#xA;    #默认用name这个list作为KEY&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.counter计数器&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from collections import counter&#xA;c= counter(...)#为内部元素计数&#xA;favs = counter(name for name,color in colors)&#xA;#为name计数,以dict返回&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.deque双向链表&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from collections import deque&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.namedtuple命名元组&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from collections import namedtuple&#xA;&#xA;animal = namedtuple(&amp;#39;animal&amp;#39;, &amp;#39;name age type&amp;#39;)&#xA;perry = animal(name=&amp;#34;perry&amp;#34;, age=31, type=&amp;#34;cat&amp;#34;)&#xA;#可以访问perry.name这样访问属性&#xA;print perry.name&#xA;#输出perry&#xA;#可将命名元组转换为dict，用_asdict()方法&#xA;perry._asdict()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;13dir&#34;&gt;13.dir()&#xA;&lt;/h4&gt;&lt;p&gt;返回对象所有属性和方法&lt;/p&gt;&#xA;&lt;p&gt;举例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a = [1,2,3]&#xA;print dir(a)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;14type和id&#34;&gt;14.type()和id()&#xA;&lt;/h4&gt;&lt;p&gt;type()返回对象类型，id()返回不同种类对象唯一ID&lt;/p&gt;&#xA;&lt;h4 id=&#34;15推导式&#34;&gt;15.推导式&#xA;&lt;/h4&gt;&lt;p&gt;1.列表推导式&lt;/p&gt;&#xA;&lt;p&gt;通过for和if生成list&lt;/p&gt;&#xA;&lt;p&gt;举例说明：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;m=[i for i in range(30) if i%3 is 0]&#xA;#------------这是list-----这是条件-----&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;语法：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;variable = [out_exp for out_exp in input_list if out_exp==2]&#xA;#----------------------------------这是list------这是条件----&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.字典推导式&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;dict = {v:k for k,v in some_dict.items()}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=124&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;《Python进阶》读书笔记(1)&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=150&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;《Python进阶》读书笔记(3)&lt;/a&gt;&lt;/p&gt;</description>
        </item><item>
            <title>(转)字符串和编码</title>
            <link>http://localhost:1313/posts/2017/09/2017-09-05-%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BC%96%E7%A0%81/</link>
            <pubDate>Tue, 05 Sep 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/09/2017-09-05-%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BC%96%E7%A0%81/</guid>
            <description>&lt;p&gt;一篇关于PYTHON字符串和编码的文章，写的很好，原地址：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;全文如下：&lt;/p&gt;&#xA;&lt;h3 id=&#34;字符编码&#34;&gt;字符编码&#xA;&lt;/h3&gt;&lt;p&gt;我们已经讲过了，字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。&lt;/p&gt;&#xA;&lt;p&gt;因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是&lt;code&gt;65535&lt;/code&gt;，4个字节可以表示的最大整数是&lt;code&gt;4294967295&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为&lt;code&gt;ASCII&lt;/code&gt;编码，比如大写字母&lt;code&gt;A&lt;/code&gt;的编码是&lt;code&gt;65&lt;/code&gt;，小写字母&lt;code&gt;z&lt;/code&gt;的编码是&lt;code&gt;122&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了&lt;code&gt;GB2312&lt;/code&gt;编码，用来把中文编进去。&lt;/p&gt;&#xA;&lt;p&gt;你可以想得到的是，全世界有上百种语言，日本把日文编到&lt;code&gt;Shift_JIS&lt;/code&gt;里，韩国把韩文编到&lt;code&gt;Euc-kr&lt;/code&gt;里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;images/0&#34; alt=&#34;char-encoding-problem&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。&lt;/p&gt;&#xA;&lt;p&gt;Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。&lt;/p&gt;&#xA;&lt;p&gt;现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。&lt;/p&gt;&#xA;&lt;p&gt;字母&lt;code&gt;A&lt;/code&gt;用ASCII编码是十进制的&lt;code&gt;65&lt;/code&gt;，二进制的&lt;code&gt;01000001&lt;/code&gt;；&lt;/p&gt;&#xA;&lt;p&gt;字符&lt;code&gt;0&lt;/code&gt;用ASCII编码是十进制的&lt;code&gt;48&lt;/code&gt;，二进制的&lt;code&gt;00110000&lt;/code&gt;，注意字符&lt;code&gt;&#39;0&#39;&lt;/code&gt;和整数&lt;code&gt;0&lt;/code&gt;是不同的；&lt;/p&gt;&#xA;&lt;p&gt;汉字&lt;code&gt;中&lt;/code&gt;已经超出了ASCII编码的范围，用Unicode编码是十进制的&lt;code&gt;20013&lt;/code&gt;，二进制的&lt;code&gt;01001110 00101101&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;你可以猜测，如果把ASCII编码的&lt;code&gt;A&lt;/code&gt;用Unicode编码，只需要在前面补0就可以，因此，&lt;code&gt;A&lt;/code&gt;的Unicode编码是&lt;code&gt;00000000 01000001&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。&lt;/p&gt;&#xA;&lt;p&gt;所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的&lt;code&gt;UTF-8&lt;/code&gt;编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;字符&lt;/th&gt;&#xA;          &lt;th&gt;ASCII&lt;/th&gt;&#xA;          &lt;th&gt;Unicode&lt;/th&gt;&#xA;          &lt;th&gt;UTF-8&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;A&lt;/td&gt;&#xA;          &lt;td&gt;01000001&lt;/td&gt;&#xA;          &lt;td&gt;00000000 01000001&lt;/td&gt;&#xA;          &lt;td&gt;01000001&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;中&lt;/td&gt;&#xA;          &lt;td&gt;x&lt;/td&gt;&#xA;          &lt;td&gt;01001110 00101101&lt;/td&gt;&#xA;          &lt;td&gt;11100100 10111000 10101101&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。&lt;/p&gt;&#xA;&lt;p&gt;搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：&lt;/p&gt;&#xA;&lt;p&gt;在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。&lt;/p&gt;&#xA;&lt;p&gt;用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;images/0&#34; alt=&#34;rw-file-utf-8&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;images/0&#34; alt=&#34;web-utf-8&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;所以你看到很多网页的源码上会有类似&lt;code&gt;&amp;lt;meta charset=&amp;quot;UTF-8&amp;quot; /&amp;gt;&lt;/code&gt;的信息，表示该网页正是用的UTF-8编码。&lt;/p&gt;&#xA;&lt;h3 id=&#34;python的字符串&#34;&gt;Python的字符串&#xA;&lt;/h3&gt;&lt;p&gt;搞清楚了令人头疼的字符编码问题后，我们再来研究Python的字符串。&lt;/p&gt;&#xA;&lt;p&gt;在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(&amp;#39;包含中文的str&amp;#39;)&#xA;包含中文的str&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于单个字符的编码，Python提供了&lt;code&gt;ord()&lt;/code&gt;函数获取字符的整数表示，&lt;code&gt;chr()&lt;/code&gt;函数把编码转换为对应的字符：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ord(&amp;#39;A&amp;#39;)&#xA;65&#xA;&amp;gt;&amp;gt;&amp;gt; ord(&amp;#39;中&amp;#39;)&#xA;20013&#xA;&amp;gt;&amp;gt;&amp;gt; chr(66)&#xA;&amp;#39;B&amp;#39;&#xA;&amp;gt;&amp;gt;&amp;gt; chr(25991)&#xA;&amp;#39;文&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果知道字符的整数编码，还可以用十六进制这么写&lt;code&gt;str&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; &amp;#39;\u4e2d\u6587&amp;#39;&#xA;&amp;#39;中文&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;两种写法完全是等价的。&lt;/p&gt;&#xA;&lt;p&gt;由于Python的字符串类型是&lt;code&gt;str&lt;/code&gt;，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把&lt;code&gt;str&lt;/code&gt;变为以字节为单位的&lt;code&gt;bytes&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;Python对&lt;code&gt;bytes&lt;/code&gt;类型的数据用带&lt;code&gt;b&lt;/code&gt;前缀的单引号或双引号表示：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;x = b&amp;#39;ABC&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要注意区分&lt;code&gt;&#39;ABC&#39;&lt;/code&gt;和&lt;code&gt;b&#39;ABC&#39;&lt;/code&gt;，前者是&lt;code&gt;str&lt;/code&gt;，后者虽然内容显示得和前者一样，但&lt;code&gt;bytes&lt;/code&gt;的每个字符都只占用一个字节。&lt;/p&gt;&#xA;&lt;p&gt;以Unicode表示的&lt;code&gt;str&lt;/code&gt;通过&lt;code&gt;encode()&lt;/code&gt;方法可以编码为指定的&lt;code&gt;bytes&lt;/code&gt;，例如：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; &amp;#39;ABC&amp;#39;.encode(&amp;#39;ascii&amp;#39;)&#xA;b&amp;#39;ABC&amp;#39;&#xA;&amp;gt;&amp;gt;&amp;gt; &amp;#39;中文&amp;#39;.encode(&amp;#39;utf-8&amp;#39;)&#xA;b&amp;#39;\xe4\xb8\xad\xe6\x96\x87&amp;#39;&#xA;&amp;gt;&amp;gt;&amp;gt; &amp;#39;中文&amp;#39;.encode(&amp;#39;ascii&amp;#39;)&#xA;Traceback (most recent call last):&#xA;  File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt;&#xA;UnicodeEncodeError: &amp;#39;ascii&amp;#39; codec can&amp;#39;t encode characters in position 0-1: ordinal not in range(128)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;纯英文的&lt;code&gt;str&lt;/code&gt;可以用&lt;code&gt;ASCII&lt;/code&gt;编码为&lt;code&gt;bytes&lt;/code&gt;，内容是一样的，含有中文的&lt;code&gt;str&lt;/code&gt;可以用&lt;code&gt;UTF-8&lt;/code&gt;编码为&lt;code&gt;bytes&lt;/code&gt;。含有中文的&lt;code&gt;str&lt;/code&gt;无法用&lt;code&gt;ASCII&lt;/code&gt;编码，因为中文编码的范围超过了&lt;code&gt;ASCII&lt;/code&gt;编码的范围，Python会报错。&lt;/p&gt;&#xA;&lt;p&gt;在&lt;code&gt;bytes&lt;/code&gt;中，无法显示为ASCII字符的字节，用&lt;code&gt;\x##&lt;/code&gt;显示。&lt;/p&gt;&#xA;&lt;p&gt;反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是&lt;code&gt;bytes&lt;/code&gt;。要把&lt;code&gt;bytes&lt;/code&gt;变为&lt;code&gt;str&lt;/code&gt;，就需要用&lt;code&gt;decode()&lt;/code&gt;方法：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; b&amp;#39;ABC&amp;#39;.decode(&amp;#39;ascii&amp;#39;)&#xA;&amp;#39;ABC&amp;#39;&#xA;&amp;gt;&amp;gt;&amp;gt; b&amp;#39;\xe4\xb8\xad\xe6\x96\x87&amp;#39;.decode(&amp;#39;utf-8&amp;#39;)&#xA;&amp;#39;中文&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要计算&lt;code&gt;str&lt;/code&gt;包含多少个字符，可以用&lt;code&gt;len()&lt;/code&gt;函数：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; len(&amp;#39;ABC&amp;#39;)&#xA;3&#xA;&amp;gt;&amp;gt;&amp;gt; len(&amp;#39;中文&amp;#39;)&#xA;2&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;len()&lt;/code&gt;函数计算的是&lt;code&gt;str&lt;/code&gt;的字符数，如果换成&lt;code&gt;bytes&lt;/code&gt;，&lt;code&gt;len()&lt;/code&gt;函数就计算字节数：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; len(b&amp;#39;ABC&amp;#39;)&#xA;3&#xA;&amp;gt;&amp;gt;&amp;gt; len(b&amp;#39;\xe4\xb8\xad\xe6\x96\x87&amp;#39;)&#xA;6&#xA;&amp;gt;&amp;gt;&amp;gt; len(&amp;#39;中文&amp;#39;.encode(&amp;#39;utf-8&amp;#39;))&#xA;6&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。&lt;/p&gt;&#xA;&lt;p&gt;在操作字符串时，我们经常遇到&lt;code&gt;str&lt;/code&gt;和&lt;code&gt;bytes&lt;/code&gt;的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对&lt;code&gt;str&lt;/code&gt;和&lt;code&gt;bytes&lt;/code&gt;进行转换。&lt;/p&gt;&#xA;&lt;p&gt;由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#!/usr/bin/env python3&#xA;# -*- coding: utf-8 -*-&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；&lt;/p&gt;&#xA;&lt;p&gt;第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。&lt;/p&gt;&#xA;&lt;p&gt;申明了UTF-8编码并不意味着你的&lt;code&gt;.py&lt;/code&gt;文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;images/001427719248811c5f9fd37acf54f6f93d7affbd80dd79b000&#34; alt=&#34;set-encoding-in-notepad&amp;#43;&amp;#43;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;如果&lt;code&gt;.py&lt;/code&gt;文件本身使用UTF-8编码，并且也申明了&lt;code&gt;# -*- coding: utf-8 -*-&lt;/code&gt;，打开命令提示符测试就可以正常显示中文：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;images/0014277193240041efdda5a5de14f58a0879d8d4efcee66000&#34; alt=&#34;py-chinese-test-in-cmd&#34; /&gt;&#xA;&lt;/p&gt;</description>
        </item><item>
            <title>一个简单的，支持自建词库的背英语单词网站</title>
            <link>http://localhost:1313/posts/2017/09/2017-09-04-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%94%AF%E6%8C%81%E8%87%AA%E5%BB%BA%E8%AF%8D%E5%BA%93%E7%9A%84%E8%83%8C%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%BD%91%E7%AB%99/</link>
            <pubDate>Mon, 04 Sep 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/09/2017-09-04-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%94%AF%E6%8C%81%E8%87%AA%E5%BB%BA%E8%AF%8D%E5%BA%93%E7%9A%84%E8%83%8C%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%BD%91%E7%AB%99/</guid>
            <description>&lt;p&gt;由于近来在学英语，需要背英语单词。但网上背英语单词的网站好像不花钱都不支持自建词库，所以就顺手自己写了一个简单而支持自建词库的背英语单词网站，自用。(&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/learn&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;www.calmkart.com/learn&lt;/a&gt;)&lt;/p&gt;&#xA;&lt;p&gt;首先需要解决的问题是英语单词的翻译过程，我的第一反应是考虑用GOOGLE翻译的API，但是经过查询，需要收费，国内的大多在线翻译的API一般也都是要收费的。 然后开始考虑用爬网页的方式去做，但因为GOOGLE有自己的防爬机制(token)，通过本地计算后再爬网页的话也比较麻烦，浪费时间。 所以最后采取了使用本地词典数据库的方法来做翻译。&lt;/p&gt;&#xA;&lt;p&gt;最复杂的地方是PYTHON中字符编码的问题，需要很多次无谓ENCODE和DECODE，于是我采用了最简单的方法，完全放弃使用python2.7，而直接采用python3.6，很好的解决了字符编码的问题。剩下的后端的东西都比较简单，无非上传查找翻译等等，见后文的代码地址。&lt;/p&gt;&#xA;&lt;p&gt;主要页面功能如下： &lt;img src=&#34;images/1.jpg&#34; alt=&#34;&#34; /&gt;&#xA; &lt;img src=&#34;images/2.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;前后端数据交互采用了由后端渲染的方式，用了flask的jinja2模板。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;这里采用jinja2模板渲染之后又一个可以考虑的地方，是用户每次切换一个单词就去服务器查询一次结果还是服务器直接查询出该用户字典所有单词结果直接传给用户，用户切词等于完全在本地通过JS操作，和服务器完全脱离关系。 在这里采用了后一种方式，直接把用户词典的所有翻译结果传给客户端，然后用户切词完全依靠JS操作，不需要再去服务器做查询，这样应该是比较快的，而且也能给服务器减轻负担。&lt;/p&gt;&#xA;&lt;p&gt;前端是采用了bootstrap框架，bootstrap的布局是分成12格，挺好用的。&lt;/p&gt;&#xA;&lt;p&gt;项目地址：&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/learn&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;www.calmkart.com/learn&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;代码已上传github,地址：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/calmkart/learn_english&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/calmkart/learn_english&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;自行使用时请先修改setting文件中的路径，用于与本地匹配。&lt;/p&gt;</description>
        </item><item>
            <title>zabbix报警收敛</title>
            <link>http://localhost:1313/posts/2017/08/2017-08-23-zabbix%E6%8A%A5%E8%AD%A6%E6%94%B6%E6%95%9B/</link>
            <pubDate>Wed, 23 Aug 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/08/2017-08-23-zabbix%E6%8A%A5%E8%AD%A6%E6%94%B6%E6%95%9B/</guid>
            <description>&lt;p&gt;因zabbix可能同一段时间报警过多，接受消息时如果不做收敛可能出错也不容易审查，所以需要一个报警收敛机制。&lt;/p&gt;&#xA;&lt;p&gt;实验环境分为server端与client端： server端模拟收敛程序通过TCP SOCKET连接接受zabbix报警，做收敛处理并发送； client端模拟zabbix报警程序，通过TCP SOCKET连接发送模拟的zabbix报警给server;&lt;/p&gt;&#xA;&lt;p&gt;server端程序如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# -*- coding:utf-8 -*-&#xA;from threading import Timer&#xA;import urllib2&#xA;import socket&#xA;import threading&#xA;import re&#xA;&#xA;#event_list为收敛类型数目列表&#xA;#ip_list为IP收敛字典列表&#xA;#summary为收敛类型说明列表&#xA;#keyw为正则匹配元素&#xA;&#xA;class convergence(object):&#xA;&#x9;event_list = [0,0,0,0]&#xA;&#x9;summary = [&amp;#39;获取uptime时间失败&amp;#39;,&amp;#39;SNMP_cant_respond_for_5minutes错误&amp;#39;,&amp;#39;OK错误&amp;#39;,&amp;#39;流量速率异常错误&amp;#39;]&#xA;&#x9;ip_list = [{},{},{},{}]&#xA;&#x9;keyw = [&amp;#39;获取uptime时间失败&amp;#39;,&amp;#39;SNMPcan\&amp;#39;trespondfor5minutes&amp;#39;,&amp;#39;ok&amp;#39;,&amp;#39;流量速度异常&amp;#39;]&#xA;&#x9;t = None&#xA;&#x9;&#xA;&#x9;def convergence(self,event):&#xA;&#x9;&#x9;temp = self.keyword(event)&#xA;&#x9;&#x9;ip = self.findip(event)&#xA;&#x9;&#x9;if temp != 0:&#xA;&#x9;&#x9;&#x9;#做报警IP收敛&#xA;&#x9;&#x9;&#x9;if self.ip_list[temp-1].has_key(ip):&#xA;&#x9;&#x9;&#x9;&#x9;self.ip_list[temp-1][ip] = self.ip_list[temp-1][ip]+1&#xA;&#x9;&#x9;&#x9;else:&#xA;&#x9;&#x9;&#x9;&#x9;self.ip_list[temp-1][ip] = 1&#xA;&#x9;&#x9;&#x9;#做报警条目收敛&#xA;&#x9;&#x9;&#x9;self.event_list[temp-1] = self.event_list[temp-1]+1&#xA;&#x9;&#x9;&#x9;if self.t == None:&#xA;&#x9;&#x9;&#x9;&#x9;self.timer(event)&#xA;&#x9;&#x9;&#x9;else:&#xA;&#x9;&#x9;&#x9;&#x9;pass&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;else:&#xA;&#x9;&#x9;&#x9;#按原格式发送&#xA;&#x9;&#x9;&#x9;print event&#xA;&#x9;&#x9;&#x9;pass&#xA;&#xA;&#x9;def send(self,event):&#xA;&#x9;&#x9;print &amp;#39;目前的缓存区为&amp;#39;+str(self.event_list)&#xA;&#x9;&#x9;if max(self.event_list) == 0:&#xA;&#x9;&#x9;&#x9;pass&#xA;&#x9;&#x9;else:&#xA;&#x9;&#x9;&#x9;for i in range(0,len(event_list)):&#xA;&#x9;&#x9;&#x9;&#x9;if self.event_list[i]==0:&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;pass&#xA;&#x9;&#x9;&#x9;&#x9;else:#发送收敛后的报警到指定位置&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;content = str(event_list[i]+&amp;#39;次&amp;#39;+self.summary[i]+&amp;#39;(前20秒内)&amp;#39;)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;self.event_list[i] = 0&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;self.t = None&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;urllib2.urlopen(&amp;#39;http://www.calmkart.com&amp;#39;)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;print content&#xA;&#xA;&#x9;def timer(self,event):#启动定时器&#xA;&#x9;&#x9;self.t = Timer(20,self.send,args=[event])&#xA;&#x9;&#x9;self.t.start()&#xA;&#x9;&#xA;&#x9;def keyword(self,event):&#xA;&#x9;&#x9;for i in range(0,len(self.keyw)):&#xA;&#x9;&#x9;&#x9;if re.search(self.keyw[i],event,flags=re.IGNORECASE) != None:&#xA;&#x9;&#x9;&#x9;&#x9;return i+1&#xA;&#x9;&#x9;return 0&#xA;&#x9;&#xA;&#x9;def findip(self,event):&#xA;&#x9;&#x9;m = re.search(r&amp;#39;(?&amp;lt;![\.\d])(?:\d{1,3}\.){3}\d{1,3}(?![\.\d])&amp;#39;,event)&#xA;&#x9;&#x9;if m is not None:&#xA;&#x9;&#x9;&#x9;ip = m.group()&#xA;&#x9;&#x9;&#x9;return str(ip)&#xA;&#x9;&#x9;return &amp;#39;查不到IP&amp;#39;&#xA;&#xA;test = convergence()&#xA;&#xA;#tcp测试,server端，接收&#xA;host = &amp;#39;0.0.0.0&amp;#39;&#xA;port = 9001&#xA;s = socket.socket()&#xA;s.bind((host,port))&#xA;s.listen(5)&#xA;&#xA;while True:&#xA;&#x9;c,addr = s.accept()&#xA;&#x9;data = c.recv(1024)&#xA;&#x9;test.convergence(data)&#xA;&#x9;&#xA;##udp测试,server端，接收&#xA;#s= socket.socket(socket.AF_INET, socket.SOCK_DGRAM)&#xA;#host = &amp;#39;10.17.16.207&amp;#39;&#xA;#port = 9001&#xA;#s.bind((host,port))&#xA;#&#xA;#while True:&#xA;#&#x9;data,addr = s.recvfrom(2048)&#xA;#&#x9;test.convergence(data)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;clent端程序如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# --- coding:utf-8 ---&#xA;import random&#xA;from multiprocessing.connection import Client&#xA;&#xA;str1 = [&#xA;&#x9;&amp;#39;192.168.0.1SNMP错误&amp;#39;,&#xA;        &amp;#39;192.168.0.2SNMP错误&amp;#39;,&#xA;        &amp;#39;192.168.0.100,OK&amp;#39;,&#xA;        &amp;#39;192.168.0.101,ok&amp;#39;,&#xA;&#x9;&amp;#39;192.168.0.102,流量速率异常&amp;#39;,&#xA;&#x9;&amp;#39;192.168.0.103,流量速率异常&amp;#39;,&#xA;&#x9;&amp;#39;192.168.0.104,获取uptime时间失败&amp;#39;,&#xA;&#x9;&amp;#39;192.168.0.105,获取uptime时间失败&amp;#39;&#xA;] &#xA;address = (&amp;#39;0.0.0.0&amp;#39;,9001)&#xA;&#xA;for i in range(0,1000):&#xA;&#x9;m = str1[random.randrange(0,11)]&#xA;&#x9;conn = Client(address)&#xA;&#x9;conn.send(m)&#xA;&#x9;conn.close&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;主要用到的工具是正则表达式做匹配&lt;/p&gt;&#xA;&lt;p&gt;代码已上传至github,地址 &lt;a class=&#34;link&#34; href=&#34;https://github.com/calmkart/Zabbix_convergence&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/calmkart/Zabbix_convergence&lt;/a&gt;&lt;/p&gt;</description>
        </item><item>
            <title>用telnetlib库实现交换机批量管理</title>
            <link>http://localhost:1313/posts/2017/08/2017-08-07-%E7%94%A8telnetlib%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%89%B9%E9%87%8F%E7%AE%A1%E7%90%86/</link>
            <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/08/2017-08-07-%E7%94%A8telnetlib%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%89%B9%E9%87%8F%E7%AE%A1%E7%90%86/</guid>
            <description>&lt;p&gt;在日常工作中，有时候会遇到需要批量操作多台交换机的情况。而交换机普遍是采用定制系统，默认是telnet登陆，即使换成ssh登陆也无法使用ansible进行统一管理，所以通过python telnetlib库实现了交换机的批量管理(交换机型号为思科2960x)&lt;/p&gt;&#xA;&lt;p&gt;实现代码如下： switch_telnet.py&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#encoding=utf-8&#xA;import sys&#xA;import telnetlib&#xA;import time&#xA;&#xA;def tel(ip,user,password):&#xA;    tn = telnetlib.Telnet(ip,port=23)&#xA;    tn.read_until(&amp;#39;Verification\r\n\r\nUsername: &amp;#39;)&#xA;    tn.write(user+&amp;#39;\n&amp;#39;)&#xA;#   tn.set_debuglevel(2)&#xA;    #password&#xA;    tn.read_until(&amp;#39;Password: &amp;#39;)&#xA;    tn.write(password+&amp;#39;\n&amp;#39;)&#xA;    #login fail&#xA;    if tn.read_some()==&amp;#39;\r\nPassword: &amp;#39;:&#xA;        print &amp;#39;\033[1;31;40m&amp;#39;+ip+&amp;#39;\033[0m&amp;#39;+&amp;#39;     password is wrong,login false!&amp;#39;&#xA;        tn.close()&#xA;        return 1&#xA;    #login successs&#xA;    tn.write(&amp;#39;enable\n&amp;#39;)&#xA;    #password&#xA;    tn.read_until(&amp;#39;Password: &amp;#39;)&#xA;    tn.write(password+&amp;#39;\n&amp;#39;)&#xA;    #enable susccess set terimal length&#xA;    tn.read_until(&amp;#39;Switch#&amp;#39;)&#xA;    tn.write(&amp;#39;ter len 0\n&amp;#39;)&#xA;    time.sleep(1)&#xA;    if tn.read_some()==&amp;#39;ter len 0\r\nSwitch#&amp;#39;:&#xA;        print ip+&amp;#39;     telnet login susccess&amp;#39;&#xA;        return tn&#xA;    print ip+&amp;#39;     terminal length 0 false!&amp;#39;&#xA;    return 1&#xA;&#xA;def comm(tn,ip,cmd):&#xA;    tn.write(cmd+&amp;#39;\n&amp;#39;)&#xA;    time.sleep(.2)&#xA;    result = tn.read_very_eager()&#xA;    print (&amp;#39;\033[1;31;40m&amp;#39;+ip+&amp;#39;\033[0m&amp;#39;+&amp;#39;   &amp;#39;+result)&#xA;&#xA;ip_list = []&#xA;user_list = []&#xA;password_list = []&#xA;tn = []&#xA;ip_fp = open(&amp;#39;ip_list&amp;#39;,&amp;#39;r&amp;#39;)&#xA;ip_fs = ip_fp.read()&#xA;ip_fp.close()&#xA;fa = ip_fs.split(&amp;#39;\n&amp;#39;)&#xA;&#xA;for i in range(0,len(fa)-1):&#xA;    f_res = fa[i].split(&amp;#39;,&amp;#39;)&#xA;    ip_list.append(f_res[0])&#xA;    user_list.append(f_res[1])&#xA;    password_list.append(f_res[2])&#xA;&#xA;for i in range(0,len(fa)-1):&#xA;    tn.append(tel(ip_list[i],user_list[i],password_list[i]))&#xA;&#xA;while 1:&#xA;    cmd = raw_input(&amp;#34;input the command: &amp;#34;)&#xA;    if cmd == &amp;#39;quit&amp;#39;:&#xA;        for i in range(0,len(fa)-1):&#xA;            tn[i].write(&amp;#39;quit\n&amp;#39;)&#xA;        break&#xA;&#xA;    for i in range(0,len(fa)-1):&#xA;        comm(tn[i],ip_list[i],cmd+&amp;#39;\n&amp;#39;)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;脚本详解：&lt;/p&gt;&#xA;&lt;p&gt;主要使用了python的telnetlib库，下面概述常见的几个方法。&lt;/p&gt;&#xA;&lt;p&gt;telnetlib.Telnet([host[, port[, timeout]]]) 此方法返回一个client对象，可操作&lt;/p&gt;&#xA;&lt;p&gt;Telnet.read_until(expected[, timeout]) 此方法阻塞读取缓存区输出，匹配expected才继续&lt;/p&gt;&#xA;&lt;p&gt;Telnet.read_all() 读取所有输出，读取到结束符或者连接中断&lt;/p&gt;&#xA;&lt;p&gt;Telnet.read_some() 读取至少一个输出&lt;/p&gt;&#xA;&lt;p&gt;Telnet.read_very_eager() 读取尽量多的输出，但记得要time.sleep()一定时间，不然会因为来不及读取所有数据导致数据丢失&lt;/p&gt;&#xA;&lt;p&gt;Telnet.write(buffer) 向client对象写入数据，记得换行符\n&lt;/p&gt;&#xA;&lt;p&gt;Telnet.close() 关闭连接&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;操作指南：&lt;/p&gt;&#xA;&lt;p&gt;使用时在同路径下编辑ip_list文件，格式为ip,username,password既可，一个交换机占一行，如下例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;10.32.19.9,cisco,123456&#xA;10.32.19.10,cisco,654321&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行 python ./switch_telnet.py&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;images/TdCoxrKTPjmnsPncPk6g.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;显示所有交换机IP的登陆情况，然后输入命令交互即可（类似ansible）&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;images/69tpvwdEhq4CEDx3XQohhQ.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;可以随意使用exit命令，但直接退出脚本指令为quit&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;其他：&lt;/p&gt;&#xA;&lt;p&gt;同类可用库还有pexpect，非常强大 如果是SSH登陆的交换机，可以使用netmiko，还可以用fabric批量管理，不再赘述&lt;/p&gt;&#xA;&lt;p&gt;项目源码已上传github &lt;a class=&#34;link&#34; href=&#34;https://github.com/calmkart/switch_telnet&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/calmkart/switch_telnet&lt;/a&gt;&lt;/p&gt;</description>
        </item></channel>
</rss>
