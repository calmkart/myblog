<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Telnetlib on cAlm的个人Blog</title>
        <link>http://localhost:1313/tags/telnetlib/</link>
        <description>Recent content in Telnetlib on cAlm的个人Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Mon, 07 Aug 2017 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/telnetlib/index.xml" rel="self" type="application/rss+xml" /><item>
            <title>用telnetlib库实现交换机批量管理</title>
            <link>http://localhost:1313/posts/2017/08/2017-08-07-%E7%94%A8telnetlib%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%89%B9%E9%87%8F%E7%AE%A1%E7%90%86/</link>
            <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/08/2017-08-07-%E7%94%A8telnetlib%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%89%B9%E9%87%8F%E7%AE%A1%E7%90%86/</guid>
            <description>&lt;p&gt;在日常工作中，有时候会遇到需要批量操作多台交换机的情况。而交换机普遍是采用定制系统，默认是telnet登陆，即使换成ssh登陆也无法使用ansible进行统一管理，所以通过python telnetlib库实现了交换机的批量管理(交换机型号为思科2960x)&lt;/p&gt;&#xA;&lt;p&gt;实现代码如下： switch_telnet.py&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#encoding=utf-8&#xA;import sys&#xA;import telnetlib&#xA;import time&#xA;&#xA;def tel(ip,user,password):&#xA;    tn = telnetlib.Telnet(ip,port=23)&#xA;    tn.read_until(&amp;#39;Verification\r\n\r\nUsername: &amp;#39;)&#xA;    tn.write(user+&amp;#39;\n&amp;#39;)&#xA;#   tn.set_debuglevel(2)&#xA;    #password&#xA;    tn.read_until(&amp;#39;Password: &amp;#39;)&#xA;    tn.write(password+&amp;#39;\n&amp;#39;)&#xA;    #login fail&#xA;    if tn.read_some()==&amp;#39;\r\nPassword: &amp;#39;:&#xA;        print &amp;#39;\033[1;31;40m&amp;#39;+ip+&amp;#39;\033[0m&amp;#39;+&amp;#39;     password is wrong,login false!&amp;#39;&#xA;        tn.close()&#xA;        return 1&#xA;    #login successs&#xA;    tn.write(&amp;#39;enable\n&amp;#39;)&#xA;    #password&#xA;    tn.read_until(&amp;#39;Password: &amp;#39;)&#xA;    tn.write(password+&amp;#39;\n&amp;#39;)&#xA;    #enable susccess set terimal length&#xA;    tn.read_until(&amp;#39;Switch#&amp;#39;)&#xA;    tn.write(&amp;#39;ter len 0\n&amp;#39;)&#xA;    time.sleep(1)&#xA;    if tn.read_some()==&amp;#39;ter len 0\r\nSwitch#&amp;#39;:&#xA;        print ip+&amp;#39;     telnet login susccess&amp;#39;&#xA;        return tn&#xA;    print ip+&amp;#39;     terminal length 0 false!&amp;#39;&#xA;    return 1&#xA;&#xA;def comm(tn,ip,cmd):&#xA;    tn.write(cmd+&amp;#39;\n&amp;#39;)&#xA;    time.sleep(.2)&#xA;    result = tn.read_very_eager()&#xA;    print (&amp;#39;\033[1;31;40m&amp;#39;+ip+&amp;#39;\033[0m&amp;#39;+&amp;#39;   &amp;#39;+result)&#xA;&#xA;ip_list = []&#xA;user_list = []&#xA;password_list = []&#xA;tn = []&#xA;ip_fp = open(&amp;#39;ip_list&amp;#39;,&amp;#39;r&amp;#39;)&#xA;ip_fs = ip_fp.read()&#xA;ip_fp.close()&#xA;fa = ip_fs.split(&amp;#39;\n&amp;#39;)&#xA;&#xA;for i in range(0,len(fa)-1):&#xA;    f_res = fa[i].split(&amp;#39;,&amp;#39;)&#xA;    ip_list.append(f_res[0])&#xA;    user_list.append(f_res[1])&#xA;    password_list.append(f_res[2])&#xA;&#xA;for i in range(0,len(fa)-1):&#xA;    tn.append(tel(ip_list[i],user_list[i],password_list[i]))&#xA;&#xA;while 1:&#xA;    cmd = raw_input(&amp;#34;input the command: &amp;#34;)&#xA;    if cmd == &amp;#39;quit&amp;#39;:&#xA;        for i in range(0,len(fa)-1):&#xA;            tn[i].write(&amp;#39;quit\n&amp;#39;)&#xA;        break&#xA;&#xA;    for i in range(0,len(fa)-1):&#xA;        comm(tn[i],ip_list[i],cmd+&amp;#39;\n&amp;#39;)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;脚本详解：&lt;/p&gt;&#xA;&lt;p&gt;主要使用了python的telnetlib库，下面概述常见的几个方法。&lt;/p&gt;&#xA;&lt;p&gt;telnetlib.Telnet([host[, port[, timeout]]]) 此方法返回一个client对象，可操作&lt;/p&gt;&#xA;&lt;p&gt;Telnet.read_until(expected[, timeout]) 此方法阻塞读取缓存区输出，匹配expected才继续&lt;/p&gt;&#xA;&lt;p&gt;Telnet.read_all() 读取所有输出，读取到结束符或者连接中断&lt;/p&gt;&#xA;&lt;p&gt;Telnet.read_some() 读取至少一个输出&lt;/p&gt;&#xA;&lt;p&gt;Telnet.read_very_eager() 读取尽量多的输出，但记得要time.sleep()一定时间，不然会因为来不及读取所有数据导致数据丢失&lt;/p&gt;&#xA;&lt;p&gt;Telnet.write(buffer) 向client对象写入数据，记得换行符\n&lt;/p&gt;&#xA;&lt;p&gt;Telnet.close() 关闭连接&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;操作指南：&lt;/p&gt;&#xA;&lt;p&gt;使用时在同路径下编辑ip_list文件，格式为ip,username,password既可，一个交换机占一行，如下例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;10.32.19.9,cisco,123456&#xA;10.32.19.10,cisco,654321&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行 python ./switch_telnet.py&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;images/TdCoxrKTPjmnsPncPk6g.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;显示所有交换机IP的登陆情况，然后输入命令交互即可（类似ansible）&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;images/69tpvwdEhq4CEDx3XQohhQ.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;可以随意使用exit命令，但直接退出脚本指令为quit&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;其他：&lt;/p&gt;&#xA;&lt;p&gt;同类可用库还有pexpect，非常强大 如果是SSH登陆的交换机，可以使用netmiko，还可以用fabric批量管理，不再赘述&lt;/p&gt;&#xA;&lt;p&gt;项目源码已上传github &lt;a class=&#34;link&#34; href=&#34;https://github.com/calmkart/switch_telnet&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/calmkart/switch_telnet&lt;/a&gt;&lt;/p&gt;</description>
        </item></channel>
</rss>
