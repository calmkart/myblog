<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Nginx on cAlm的个人Blog</title>
        <link>http://localhost:1313/tags/nginx/</link>
        <description>Recent content in Nginx on cAlm的个人Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Sat, 25 May 2019 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/nginx/index.xml" rel="self" type="application/rss+xml" /><item>
            <title>kubernetes集群中服务的负载均衡和外部发现</title>
            <link>http://localhost:1313/posts/2019/05/2019-05-25-kubernetes%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E5%A4%96%E9%83%A8%E5%8F%91%E7%8E%B0/</link>
            <pubDate>Sat, 25 May 2019 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2019/05/2019-05-25-kubernetes%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E5%A4%96%E9%83%A8%E5%8F%91%E7%8E%B0/</guid>
            <description>&lt;p&gt;传统的负载均衡策略一般是:&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;客户端 -&amp;gt; dns -&amp;gt; 4层库在均衡(HA) -&amp;gt; 7层负载均衡 -&amp;gt; 具体的后端服务&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;这种方式处理服务发现和动态配置比较难搞,比如后端服务动态扩缩容什么的。 一开始的做法肯定是OP人工维护7层负载均衡集群配置，以nginx为例，用git仓库之类的做人工服务发现和变更。这样很显然是不科学的。然后就会开始希望用种种自动化的手段去处理服务发现，比如微博的nginx-upsync-module,比如nginx-lua，比如openresty，比如etcd+confd等种种手段实现服务发现和自动化配置，但还是有很多瑕疵，比如etcd+confd每次修改upstream的服务后端就要reload nginx，nginx的策略会新开x个worker，容易造成性能问题甚至机器顶不住。而且vm服务机器的逻辑和upstream挂钩也有问题，总之，麻烦的很。&lt;/p&gt;&#xA;&lt;p&gt;而kubernetes处理这一套服务发现和负载均衡的方法就挺好用的，比如接下来会实践的这一套nginx-ingress+externalIP+dns的方式就很直观而且方便自动化流程，大致策略如下:&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;客户端 -&amp;gt; dns -&amp;gt; k8s-nginx-ingress-service(in ExternalIP) -&amp;gt; ingress-obj -&amp;gt; service -&amp;gt; pod&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;kubernetes集群中具体工作的pod是由service做负载均衡和服务发现的，而service的外部发现策略通常有NodePort，Kube-proxy以及Ingress。对于内部服务暴露给外部，NodePort基本上是不好用的，因为本来Port就有限，而且如果是web服务(80,443)，需要接dns的，开在30000+端口以上，还得在外部做一个四层负载均衡，这样就很烦。Kube-proxy用在调试环境还行，同样有以上问题，所以Ingress是更好的选择。&lt;/p&gt;&#xA;&lt;p&gt;nginx-ingress采用了nginx-lua模块实现upstream动态修正，无需reload nginx，可以解决上述提到的2x worker导致性能下降问题。且结合了service的pods自动发现(coredns)，轻松简单的完成很多过去很麻烦的任务。&lt;/p&gt;&#xA;&lt;p&gt;首先在上篇blog里我们已经有了一个k8s集群，然后我们创建ingress-nginx相关的api对象&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/mandatory.yaml&#xA;kubectl apply -f mandatory.yaml&#xA;&#xA;#会创建好相应的ingress-nginx controller和rbac相关api&#xA;[root@xxxxxxxx ingress-nginx]# kubectl get pods -n ingress-nginx&#xA;NAME                                        READY   STATUS    RESTARTS   AGE&#xA;nginx-ingress-controller-5694ccb578-hwj2j   1/1     Running   0          3h11m&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们创建一个ingress的service，用ExternalIP的方式暴露给集群外部&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vim externalIp-ingress-service.yaml&#xA;&#xA;apiVersion: v1&#xA;kind: Service&#xA;metadata:&#xA;  name: ingress-nginx&#xA;  namespace: ingress-nginx&#xA;  labels:&#xA;    app.kubernetes.io/name: ingress-nginx&#xA;    app.kubernetes.io/part-of: ingress-nginx&#xA;spec:&#xA;  ports:&#xA;    - name: http&#xA;      port: 80&#xA;      protocol: TCP&#xA;    - name: https&#xA;      port: 443&#xA;      protocol: TCP&#xA;  selector:&#xA;    app.kubernetes.io/name: ingress-nginx&#xA;    app.kubernetes.io/part-of: ingress-nginx&#xA;  externalIPs:&#xA;    #这里填写你的k8s masterip&#xA;    - 10.1.33.159&#xA;&#xA;#将创建出如下服务&#xA;[root@xxxxxxxxxxxx ingress-nginx]# kubectl get service -n ingress-nginx&#xA;NAME            TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE&#xA;ingress-nginx   ClusterIP   10.96.139.222   10.1.33.159   80/TCP,443/TCP   3h12m&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来我们就可以创建具体的ingress对象了&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vim rook-ceph-ingress.yaml&#xA;&#xA;apiVersion: extensions/v1beta1&#xA;kind: Ingress&#xA;metadata:&#xA;  name: rook-ceph-ingress&#xA;  annotations:&#xA;    nginx.ingress.kubernetes.io/ssl-redirect: &amp;#34;false&amp;#34;&#xA;  #要暴露的service对应的命名空间  &#xA;  namespace: rook-ceph&#xA;spec:&#xA;  rules:&#xA;  #这里按需配置,就是nginx的配置方法,具体查下ingress-nginx的项目文档&#xA;  - host: k8s-ceph-dashboard.calmkart.com&#xA;    http:&#xA;      paths:&#xA;      - path: /&#xA;        backend:&#xA;          serviceName: rook-ceph-mgr-dashboard&#xA;          servicePort: 8443&#xA;&#xA;kubectl apply -f rook-ceph-ingress.yaml&#xA;#这个ingress将自动发现rook-ceph命名空间中的rook-ceph-mgr-dashboard服务，并将之作负载均衡对外暴露&#xA;[root@xxxxxxxxxxx ingress]# kubectl get service -n rook-ceph&#xA;NAME                      TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)             AGE&#xA;rook-ceph-mgr             ClusterIP   10.99.37.148             9283/TCP            3h48m&#xA;rook-ceph-mgr-dashboard   ClusterIP   10.110.163.110           8443/TCP            3h48m&#xA;rook-ceph-mon-a           ClusterIP   10.103.5.55              6789/TCP,3300/TCP   3h49m&#xA;rook-ceph-mon-b           ClusterIP   10.104.22.199            6789/TCP,3300/TCP   3h49m&#xA;rook-ceph-mon-c           ClusterIP   10.110.80.82             6789/TCP,3300/TCP   3h49m&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们查看一下ingress状态&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[root@xxxxxxxxxx ingress]# kubectl get ingress -n rook-ceph&#xA;NAME                HOSTS                                ADDRESS       PORTS   AGE&#xA;rook-ceph-ingress   k8s-ceph-dashboard.calmkart.com   10.1.33.159   80      170m&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就没问题了 最后我们把dns记录k8s-ceph-dashboard.calmkart.com指向10.1.33.159&lt;/p&gt;&#xA;&lt;p&gt;搞定。&lt;/p&gt;</description>
        </item><item>
            <title>myip.calmkart.com获取自己的出口ip</title>
            <link>http://localhost:1313/posts/2019/04/2019-04-02-myip-calmkart-com%E8%8E%B7%E5%8F%96%E8%87%AA%E5%B7%B1%E7%9A%84%E5%87%BA%E5%8F%A3ip/</link>
            <pubDate>Tue, 02 Apr 2019 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2019/04/2019-04-02-myip-calmkart-com%E8%8E%B7%E5%8F%96%E8%87%AA%E5%B7%B1%E7%9A%84%E5%87%BA%E5%8F%A3ip/</guid>
            <description>&lt;p&gt;最近在学陶辉的Nginx核心知识100讲,听到postread阶段的时候,顺手用realip模块弄了个小东西,用来获取自己的出口ip.&lt;/p&gt;&#xA;&lt;p&gt;地址myip.calmkart.com&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# curl或访问myip.calmkart.com即可，将返回你的出口ip&#xA;curl myip.calmkart.com&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类似ifconfig.me，不细说了，小东西，留个存根。&lt;/p&gt;&#xA;</description>
        </item><item>
            <title>一个自解析nginx upstream和location并检测连通性的web系统</title>
            <link>http://localhost:1313/posts/2018/07/2018-07-23-%E4%B8%80%E4%B8%AA%E8%87%AA%E8%A7%A3%E6%9E%90nginx-upstream%E5%92%8Clocation%E5%B9%B6%E6%A3%80%E6%B5%8B%E8%BF%9E%E9%80%9A%E6%80%A7%E7%9A%84web%E7%B3%BB%E7%BB%9F/</link>
            <pubDate>Mon, 23 Jul 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/07/2018-07-23-%E4%B8%80%E4%B8%AA%E8%87%AA%E8%A7%A3%E6%9E%90nginx-upstream%E5%92%8Clocation%E5%B9%B6%E6%A3%80%E6%B5%8B%E8%BF%9E%E9%80%9A%E6%80%A7%E7%9A%84web%E7%B3%BB%E7%BB%9F/</guid>
            <description>&lt;p&gt;最近做的一个小web系统，主要的思路是，怎样才能将nginx集群的海量配置文件,包括server和upstream及location等完全对象化 想做的东西就类似于httpdns，将nginx的海量配置文件对象化，或者考虑能不能数据库化 现在的功能只是解析所有nginx配置文件,自动读取upstream列表和location中proxy_pass,然后做连接性追踪 当然,追踪列表也可自定义添加,在admin后台配置即可 最终效果图 &lt;img src=&#34;images/custom.png&#34; alt=&#34;custom&#34; /&gt;&#xA; &lt;img src=&#34;images/back.png&#34; alt=&#34;back&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;git地址 &lt;a class=&#34;link&#34; href=&#34;https://github.com/calmkart/check_port&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/calmkart/check_port&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#大致部署过程&#xA;pip install -r pip.text&#xA;#创建checkport数据库&#xA;#修改settings.py中的数据库配置&#xA;python manage.py makemigrations&#xA;python manage.py migrate&#xA;#安装redis,修改settings.py中的redis配置&#xA;#修改readnginx的handle.py和handle_test.py中的CONFIG_PATH以及GIT_PATH(用于自动解析和更新nginx配置)&#xA;#用supervisor启动系统&#xA;supervisord -c checkport/supervisord.conf&#xA;#此外,flower需要用nginx做转发,参考配置文件如下&#xA;location ~ ^/flower/? {&#xA;rewrite ^/flower/?(.*)$ /$1 break;&#xA;&#xA;sub_filter &amp;#39;=&amp;#34;/&amp;#39; &amp;#39;=&amp;#34;/flower/&amp;#39;;&#xA;sub_filter_last_modified on;&#xA;sub_filter_once off;&#xA;&#xA;# proxy_pass http://unix:/tmp/flower.sock:/;&#xA;proxy_pass http://xxxxxxxxxxxxxxxx;&#xA;proxy_redirect off;&#xA;proxy_set_header Host $host;&#xA;proxy_set_header Upgrade $http_upgrade;&#xA;proxy_set_header Connection &amp;#34;upgrade&amp;#34;;&#xA;proxy_http_version 1.1;&#xA;}&#xA;&#xA;其中三种常见操作为:&#xA;1.将nginx配置文件列表pull到最新&#xA;2.自动读取和解析nginx配置文件,并将获取的upstream以及proxy_pass列表写进数据库&#xA;3.探测数据库中所有需要探测的IP:PORT对象实例&#xA;&#xA;可在后台管理-&amp;gt;数据更新中手动按键更新&#xA;也可在admin后台配置Periodic tasks的celery beat定时任务&#xA;其中:&#xA;1.readnginx.tasks.git_pull_config 任务更新nginx配置文件仓库&#xA;2.pubstatus.tasks.get_status 任务获取所有IP:PORT对象状态&#xA;3.readnginx.tasks.read_nginx 任务度读取nginx配置文件并解析,更新数据库IP:PORT对象列表&#xA;可根据需求设置定时任务周期&#xA;通过flower后台可以查看任务执行情况&#xA;&#xA;自定义追踪checkport的IP:PORT列表通过admin后台添加instance即可实现&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
        </item><item>
            <title>利用nginx_upload_module搭建http文件服务器</title>
            <link>http://localhost:1313/posts/2018/04/2018-04-24-%E5%88%A9%E7%94%A8nginx_upload_module%E6%90%AD%E5%BB%BAhttp%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
            <pubDate>Tue, 24 Apr 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/04/2018-04-24-%E5%88%A9%E7%94%A8nginx_upload_module%E6%90%AD%E5%BB%BAhttp%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
            <description>&lt;p&gt;服务端主要就是用的nginx-upload-module和nginx-fancyindex两个nginx模块做接收，然后python后端做处理 然后客户端的编写分为两部分,一部分是python客户端,用的requests库,另一部分是web客户端,用的是Huploadify框架&lt;/p&gt;&#xA;&lt;p&gt;结果大致如下: &lt;img src=&#34;images/9F609413-78FF-43FD-96F7-7B63BC01B37B.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;img src=&#34;images/%e4%bc%81%e4%b8%9a%e5%be%ae%e4%bf%a1%e6%88%aa%e5%9b%be_4a62da5a-4642-4639-b2b6-8b32827c5195.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;大致画一下前后端结构&lt;/p&gt;&#xA;&lt;p&gt;client.py &amp;ndash;&amp;gt; nginx-upload-module(temp) &amp;ndash;&amp;gt;python module&lt;/p&gt;&#xA;&lt;p&gt;nginx-upload-page &amp;ndash;&amp;gt; nginx-upload-module(temp) &amp;mdash;&amp;gt; python module 详情比较简单,不细述.&lt;/p&gt;&#xA;&lt;p&gt;源代码git地址: &lt;a class=&#34;link&#34; href=&#34;https://github.com/calmkart/nginx_upload&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/calmkart/nginx_upload&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;https://github.com/calmkart/nginx_upload_page&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/calmkart/nginx_upload_page&lt;/a&gt;&lt;/p&gt;</description>
        </item><item>
            <title>增强nginx的autoindex功能(文件排序，文件MD5值)</title>
            <link>http://localhost:1313/posts/2017/12/2017-12-18-%E5%A2%9E%E5%BC%BAnginx%E7%9A%84autoindex%E5%8A%9F%E8%83%BD%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F%E6%96%87%E4%BB%B6md5%E5%80%BC/</link>
            <pubDate>Mon, 18 Dec 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/12/2017-12-18-%E5%A2%9E%E5%BC%BAnginx%E7%9A%84autoindex%E5%8A%9F%E8%83%BD%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F%E6%96%87%E4%BB%B6md5%E5%80%BC/</guid>
            <description>&lt;p&gt;原始的nginx文件服务器autoindex功能非常单一，也不够美观，连按时间或者文件大小排序功能都没有，所以通过nginx插件和修改源码的方式为其增加了一些新的功能。 最终效果如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;images/zzxg-1.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;用到的插件为file-md5和ngx-fancyindex，nginx版本是1.6.2&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git clone https://github.com/cfsego/file-md5.git&#xA;git clone https://github.com/aperezdc/ngx-fancyindex.git&#xA;wget https://github.com/nginx/nginx/archive/release-1.6.2.tar.gz&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改/ngx-fancyindex/template.h文件&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//插入script&#xA;&amp;#34;&amp;lt;script src=\&amp;#34;https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js\&amp;#34;&amp;gt;&amp;#34;&#xA;&amp;#34;&amp;lt;/script&amp;gt;&amp;#34;&#xA;&amp;#34;&amp;lt;script src=\&amp;#34;/static/md5.js\&amp;#34;&amp;gt;&amp;#34;&#xA;&amp;#34;&amp;lt;/script&amp;gt;&amp;#34;&#xA;//修改页面表格宽度&#xA;&amp;#34;&amp;lt;tr&amp;gt;&amp;#34;&#xA;&amp;#34;&amp;lt;th style=\&amp;#34;width:30%\&amp;#34;&amp;gt;&amp;lt;a href=\&amp;#34;?C=N&amp;amp;O=A\&amp;#34;&amp;gt;File Name&amp;lt;/a&amp;gt;&amp;amp;nbsp;&amp;lt;a href=\&amp;#34;?C=N&amp;amp;O=D\&amp;#34;&amp;gt;&amp;amp;nbsp;&amp;amp;darr;&amp;amp;nbsp;&amp;lt;/a&amp;gt;&amp;lt;/th&amp;gt;&amp;#34;&#xA;&amp;#34;&amp;lt;th style=\&amp;#34;width:35%\&amp;#34;&amp;gt;&amp;lt;a href=\&amp;#34;?C=S&amp;amp;O=A\&amp;#34;&amp;gt;File Size&amp;lt;/a&amp;gt;&amp;amp;nbsp;&amp;lt;a href=\&amp;#34;?C=S&amp;amp;O=D\&amp;#34;&amp;gt;&amp;amp;nbsp;&amp;amp;darr;&amp;amp;nbsp;&amp;lt;/a&amp;gt;&amp;lt;/th&amp;gt;&amp;#34;&#xA;&amp;#34;&amp;lt;th style=\&amp;#34;width:25%\&amp;#34;&amp;gt;&amp;lt;a href=\&amp;#34;?C=M&amp;amp;O=A\&amp;#34;&amp;gt;Date&amp;lt;/a&amp;gt;&amp;amp;nbsp;&amp;lt;a href=\&amp;#34;?C=M&amp;amp;O=D\&amp;#34;&amp;gt;&amp;amp;nbsp;&amp;amp;darr;&amp;amp;nbsp;&amp;lt;/a&amp;gt;&amp;lt;/th&amp;gt;&amp;#34;&#xA;&amp;#34;&amp;lt;/tr&amp;gt;&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接着执行&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cd ./nginx-release-1.6.2&#xA;./auto/configure --prefix=/usr/local/nginx --with-pcre --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --add-module=../file-md5-master --add-module=../ngx-fancyindex&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后修改nginx配置文件&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vi /etc/nginx/site-enable/default&#xA;###########################&#xA;更多fancyindex插件配置选项参考&#xA;http://www.ttlsa.com/nginx/nginx-module-ngx-fancyindex/&#xA;https://www.nginx.com/resources/wiki/modules/fancy_index/#directives&#xA;###########################&#xA;root /var/www; //改为需要路径，测试机中是/var/www/&#xA;location / {&#xA; 36         # First attempt to serve request as file, then&#xA; 37         # as directory, then fall back to displaying a 404.&#xA; 38         fancyindex on;&#xA; 39         fancyindex_exact_size off;&#xA; 40         fancyindex_ignore &amp;#34;static&amp;#34;;&#xA; 41         add_header Content-MD5 $file_md5;&#xA; 42     }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在需要分享的路径创建文件./static/md5.js，测试机中是/var/www/&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mkdir /var/www/static&#xA;vi /var/www/static/md5.js&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$(document).ready(function(){&#xA;&#x9;var current_index = 1;&#xA;&#x9;function get_md5(){&#xA;&#x9;&#x9;if(current_index==$(&amp;#34;tr&amp;#34;).length){&#xA;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;var url = $(&amp;#34;tr&amp;#34;)[current_index].childNodes[0].childNodes[0].href;&#xA;&#x9;&#x9;$.ajax({&#xA;        &#x9;url: url,           &#xA;        &#x9;type: &amp;#34;HEAD&amp;#34;,&#xA;        &#x9;complete: function(jqXHR, textStatus) {&#xA;        &#x9;&#x9;var file_size = $(&amp;#34;tr&amp;#34;)[current_index].childNodes[1].childNodes[0].data;     &#xA;        &#x9;&#x9;var md5 = jqXHR.getResponseHeader(&amp;#34;Content-MD5&amp;#34;);&#xA;        &#x9;&#x9;console.log(jqXHR.getAllResponseHeaders());&#xA;        &#x9;&#x9;if(md5!=null &amp;amp;&amp;amp; file_size!=&amp;#34;-&amp;#34;){&#xA;        &#x9;&#x9;&#x9;$(&amp;#34;tr&amp;#34;)[current_index].childNodes[1].innerHTML += (&amp;#34;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp&amp;#34;+&amp;#34;[md5:&amp;#34;+md5+&amp;#34;]&amp;#34;);&#xA;        &#x9;&#x9;&#x9;}&#xA;        &#x9;&#x9;current_index++;&#xA;        &#x9;&#x9;get_md5();&#xA;        &#x9;&#x9;}&#xA;    &#x9;&#x9;});&#xA;&#x9;&#x9;}&#xA;&#x9;get_md5();&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在nginx-release-1.6.2目录下&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;killall nginx&#xA;cd ./objs&#xA;./nginx -c /etc/nginx/nginx.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即可&lt;/p&gt;&#xA;&lt;h4 id=&#34;关于md5js原理的一些小说明&#34;&gt;&lt;strong&gt;关于md5.js原理的一些小说明：&lt;/strong&gt;&#xA;&lt;/h4&gt;&lt;p&gt;file-md5模块是第三方模块，必须通过手动编译安装。 功能是将文件md5值插入文件的http头的Content-MD5字段中，效果如图&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;images/2.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;在ngx-fancyindex源码中，调用md5.js的js脚本，从前端通过jquery ajax读取所有文件http头重的Content-MD5字段，再写入页面中。&lt;/p&gt;&#xA;&lt;p&gt;因为ajax是异步的，所以无法通过普通的for循环或者赋值给全局变量的方式运行，所以要用递归+回调函数的方式，才能达成正确的效果。&lt;/p&gt;&#xA;&lt;p&gt;设置递归终止条件current_index==$(&amp;ldquo;tr&amp;rdquo;).length，循环遍历所有的文件连接，提取http头中的md5值写入页面中即可。&lt;/p&gt;&#xA;&lt;p&gt;但性能还是有些问题的，有些大文件的计算比较浪费时间。这里已经将ajax的请求type换成了HEAD类型，因为不再请求文件主体，所以请求速度是GET类型的10倍以上。&lt;/p&gt;&#xA;&lt;p&gt;所有文件git地址： &lt;a class=&#34;link&#34; href=&#34;https://github.com/calmkart/nginx_autoindex-&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/calmkart/nginx_autoindex-&lt;/a&gt; 编译好的nginx可执行文件： &lt;a class=&#34;link&#34; href=&#34;https://github.com/calmkart/nginx_autoindex-/archive/0.1.tar.gz&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/calmkart/nginx_autoindex-/archive/0.1.tar.gz&lt;/a&gt;&lt;/p&gt;</description>
        </item><item>
            <title>nginx配置文件nginx.conf中文详解</title>
            <link>http://localhost:1313/posts/2017/11/2017-11-21-nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6nginx-conf%E4%B8%AD%E6%96%87%E8%AF%A6%E8%A7%A3/</link>
            <pubDate>Tue, 21 Nov 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/11/2017-11-21-nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6nginx-conf%E4%B8%AD%E6%96%87%E8%AF%A6%E8%A7%A3/</guid>
            <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;######Nginx配置文件nginx.conf中文详解#####&#xA;&#xA;#定义Nginx运行的用户和用户组&#xA;user www www;&#xA;&#xA;#nginx进程数，建议设置为等于CPU总核心数。&#xA;worker_processes 8;&#xA; &#xA;#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]&#xA;error_log /usr/local/nginx/logs/error.log info;&#xA;&#xA;#进程pid文件&#xA;pid /usr/local/nginx/logs/nginx.pid;&#xA;&#xA;&#xA;&#xA;#指定进程可以打开的最大描述符：数目&#xA;#工作模式与连接数上限&#xA;#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。&#xA;#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。&#xA;#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。&#xA;worker_rlimit_nofile 65535;&#xA;&#xA;events&#xA;{&#xA;    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型&#xA;    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。&#xA;    #补充说明：&#xA;    #与apache相类，nginx针对不同的操作系统，有不同的事件模型&#xA;    #A）标准事件模型&#xA;    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll&#xA;    #B）高效事件模型&#xA;    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。&#xA;    #Epoll：使用于Linux内核2.6版本及以后的系统。&#xA;    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。&#xA;    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。&#xA;    use epoll;&#xA;&#xA;    #单个进程最大连接数（最大连接数=连接数*进程数）&#xA;    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。&#xA;    worker_connections 65535;&#xA;&#xA;    #keepalive超时时间。&#xA;    keepalive_timeout 60;&#xA;&#xA;    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。&#xA;    #分页大小可以用命令getconf PAGESIZE 取得。&#xA;    #[root@web001 ~]# getconf PAGESIZE&#xA;    #4096&#xA;    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。&#xA;    client_header_buffer_size 4k;&#xA;&#xA;    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。&#xA;    open_file_cache max=65535 inactive=60s;&#xA;&#xA;    #这个是指多长时间检查一次缓存的有效信息。&#xA;    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.&#xA;    open_file_cache_valid 80s;&#xA;&#xA;    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。&#xA;    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.&#xA;    open_file_cache_min_uses 1;&#xA;    &#xA;    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.&#xA;    open_file_cache_errors on;&#xA;}&#xA; &#xA; &#xA; &#xA;#设定http服务器，利用它的反向代理功能提供负载均衡支持&#xA;http&#xA;{&#xA;    #文件扩展名与文件类型映射表&#xA;    include mime.types;&#xA;&#xA;    #默认文件类型&#xA;    default_type application/octet-stream;&#xA;&#xA;    #默认编码&#xA;    #charset utf-8;&#xA;&#xA;    #服务器名字的hash表大小&#xA;    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.&#xA;    server_names_hash_bucket_size 128;&#xA;&#xA;    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。&#xA;    client_header_buffer_size 32k;&#xA;&#xA;    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。&#xA;    large_client_header_buffers 4 64k;&#xA;&#xA;    #设定通过nginx上传文件的大小&#xA;    client_max_body_size 8m;&#xA;&#xA;    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。&#xA;    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。&#xA;    sendfile on;&#xA;&#xA;    #开启目录列表访问，合适下载服务器，默认关闭。&#xA;    autoindex on;&#xA;&#xA;    #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用&#xA;    tcp_nopush on;&#xA;     &#xA;    tcp_nodelay on;&#xA;&#xA;    #长连接超时时间，单位是秒&#xA;    keepalive_timeout 120;&#xA;&#xA;    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。&#xA;    fastcgi_connect_timeout 300;&#xA;    fastcgi_send_timeout 300;&#xA;    fastcgi_read_timeout 300;&#xA;    fastcgi_buffer_size 64k;&#xA;    fastcgi_buffers 4 64k;&#xA;    fastcgi_busy_buffers_size 128k;&#xA;    fastcgi_temp_file_write_size 128k;&#xA;&#xA;    #gzip模块设置&#xA;    gzip on; #开启gzip压缩输出&#xA;    gzip_min_length 1k;    #最小压缩文件大小&#xA;    gzip_buffers 4 16k;    #压缩缓冲区&#xA;    gzip_http_version 1.0;    #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）&#xA;    gzip_comp_level 2;    #压缩等级&#xA;    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。&#xA;    gzip_vary on;&#xA;&#xA;    #开启限制IP连接数的时候需要使用&#xA;    #limit_zone crawler $binary_remote_addr 10m;&#xA;&#xA;    #负载均衡配置&#xA;    upstream jh.w3cschool.cn {&#xA;     &#xA;        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。&#xA;        server 192.168.80.121:80 weight=3;&#xA;        server 192.168.80.122:80 weight=2;&#xA;        server 192.168.80.123:80 weight=3;&#xA;&#xA;        #nginx的upstream目前支持4种方式的分配&#xA;        #1、轮询（默认）&#xA;        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。&#xA;        #2、weight&#xA;        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。&#xA;        #例如：&#xA;        #upstream bakend {&#xA;        #    server 192.168.0.14 weight=10;&#xA;        #    server 192.168.0.15 weight=10;&#xA;        #}&#xA;        #2、ip_hash&#xA;        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。&#xA;        #例如：&#xA;        #upstream bakend {&#xA;        #    ip_hash;&#xA;        #    server 192.168.0.14:88;&#xA;        #    server 192.168.0.15:80;&#xA;        #}&#xA;        #3、fair（第三方）&#xA;        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。&#xA;        #upstream backend {&#xA;        #    server server1;&#xA;        #    server server2;&#xA;        #    fair;&#xA;        #}&#xA;        #4、url_hash（第三方）&#xA;        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。&#xA;        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法&#xA;        #upstream backend {&#xA;        #    server squid1:3128;&#xA;        #    server squid2:3128;&#xA;        #    hash $request_uri;&#xA;        #    hash_method crc32;&#xA;        #}&#xA;&#xA;        #tips:&#xA;        #upstream bakend{#定义负载均衡设备的Ip及设备状态}{&#xA;        #    ip_hash;&#xA;        #    server 127.0.0.1:9090 down;&#xA;        #    server 127.0.0.1:8080 weight=2;&#xA;        #    server 127.0.0.1:6060;&#xA;        #    server 127.0.0.1:7070 backup;&#xA;        #}&#xA;        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;&#xA;&#xA;        #每个设备的状态设置为:&#xA;        #1.down表示单前的server暂时不参与负载&#xA;        #2.weight为weight越大，负载的权重就越大。&#xA;        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误&#xA;        #4.fail_timeout:max_fails次失败后，暂停的时间。&#xA;        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。&#xA;&#xA;        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。&#xA;        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug&#xA;        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录&#xA;        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡&#xA;    }&#xA;     &#xA;     &#xA;     &#xA;    #虚拟主机的配置&#xA;    server&#xA;    {&#xA;        #监听端口&#xA;        listen 80;&#xA;&#xA;        #域名可以有多个，用空格隔开&#xA;        server_name www.w3cschool.cn w3cschool.cn;&#xA;        index index.html index.htm index.php;&#xA;        root /data/www/w3cschool;&#xA;&#xA;        #对******进行负载均衡&#xA;        location ~ .*.(php|php5)?$&#xA;        {&#xA;            fastcgi_pass 127.0.0.1:9000;&#xA;            fastcgi_index index.php;&#xA;            include fastcgi.conf;&#xA;        }&#xA;         &#xA;        #图片缓存时间设置&#xA;        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$&#xA;        {&#xA;            expires 10d;&#xA;        }&#xA;         &#xA;        #JS和CSS缓存时间设置&#xA;        location ~ .*.(js|css)?$&#xA;        {&#xA;            expires 1h;&#xA;        }&#xA;         &#xA;        #日志格式设定&#xA;        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；&#xA;        #$remote_user：用来记录客户端用户名称；&#xA;        #$time_local： 用来记录访问时间与时区；&#xA;        #$request： 用来记录请求的url与http协议；&#xA;        #$status： 用来记录请求状态；成功是200，&#xA;        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；&#xA;        #$http_referer：用来记录从那个页面链接访问过来的；&#xA;        #$http_user_agent：记录客户浏览器的相关信息；&#xA;        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。&#xA;        log_format access &amp;#39;$remote_addr - $remote_user [$time_local] &amp;#34;$request&amp;#34; &amp;#39;&#xA;        &amp;#39;$status $body_bytes_sent &amp;#34;$http_referer&amp;#34; &amp;#39;&#xA;        &amp;#39;&amp;#34;$http_user_agent&amp;#34; $http_x_forwarded_for&amp;#39;;&#xA;         &#xA;        #定义本虚拟主机的访问日志&#xA;        access_log  /usr/local/nginx/logs/host.access.log  main;&#xA;        access_log  /usr/local/nginx/logs/host.access.404.log  log404;&#xA;         &#xA;        #对 &amp;#34;/&amp;#34; 启用反向代理&#xA;        location / {&#xA;            proxy_pass http://127.0.0.1:88;&#xA;            proxy_redirect off;&#xA;            proxy_set_header X-Real-IP $remote_addr;&#xA;             &#xA;            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP&#xA;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#xA;             &#xA;            #以下是一些反向代理的配置，可选。&#xA;            proxy_set_header Host $host;&#xA;&#xA;            #允许客户端请求的最大单文件字节数&#xA;            client_max_body_size 10m;&#xA;&#xA;            #缓冲区代理缓冲用户端请求的最大字节数，&#xA;            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。&#xA;            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误&#xA;            client_body_buffer_size 128k;&#xA;&#xA;            #表示使nginx阻止HTTP应答代码为400或者更高的应答。&#xA;            proxy_intercept_errors on;&#xA;&#xA;            #后端服务器连接的超时时间_发起握手等候响应超时时间&#xA;            #nginx跟后端服务器连接超时时间(代理连接超时)&#xA;            proxy_connect_timeout 90;&#xA;&#xA;            #后端服务器数据回传时间(代理发送超时)&#xA;            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据&#xA;            proxy_send_timeout 90;&#xA;&#xA;            #连接成功后，后端服务器响应时间(代理接收超时)&#xA;            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）&#xA;            proxy_read_timeout 90;&#xA;&#xA;            #设置代理服务器（nginx）保存用户头信息的缓冲区大小&#xA;            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小&#xA;            proxy_buffer_size 4k;&#xA;&#xA;            #proxy_buffers缓冲区，网页平均在32k以下的设置&#xA;            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k&#xA;            proxy_buffers 4 32k;&#xA;&#xA;            #高负荷下缓冲大小（proxy_buffers*2）&#xA;            proxy_busy_buffers_size 64k;&#xA;&#xA;            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长&#xA;            #设定缓存文件夹大小，大于这个值，将从upstream服务器传&#xA;            proxy_temp_file_write_size 64k;&#xA;        }&#xA;         &#xA;         &#xA;        #设定查看Nginx状态的地址&#xA;        location /NginxStatus {&#xA;            stub_status on;&#xA;            access_log on;&#xA;            auth_basic &amp;#34;NginxStatus&amp;#34;;&#xA;            auth_basic_user_file confpasswd;&#xA;            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。&#xA;        }&#xA;         &#xA;        #本地动静分离反向代理配置&#xA;        #所有jsp的页面均交由tomcat或resin处理&#xA;        location ~ .(jsp|jspx|do)?$ {&#xA;            proxy_set_header Host $host;&#xA;            proxy_set_header X-Real-IP $remote_addr;&#xA;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#xA;            proxy_pass http://127.0.0.1:8080;&#xA;        }&#xA;         &#xA;        #所有静态文件由nginx直接读取不经过tomcat或resin&#xA;        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|&#xA;        pdf|xls|mp3|wma)$&#xA;        {&#xA;            expires 15d; &#xA;        }&#xA;         &#xA;        location ~ .*.(js|css)?$&#xA;        {&#xA;            expires 1h;&#xA;        }&#xA;    }&#xA;}&#xA;######Nginx配置文件nginx.conf中文详解#####&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
        </item><item>
            <title>vim/nginx语法高亮插件</title>
            <link>http://localhost:1313/posts/2017/11/2017-11-20-vim-nginx%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E6%8F%92%E4%BB%B6/</link>
            <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/11/2017-11-20-vim-nginx%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E6%8F%92%E4%BB%B6/</guid>
            <description>&lt;p&gt;1.vim语法高亮插件molokai&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cd ~/.vim/&#xA;mkdir ./colors&#xA;cd ./colos&#xA;wget https://raw.githubusercontent.com/tomasr/molokai/master/colors/molokai.vim&#xA;echo colorscheme molokai  &amp;gt;&amp;gt; ~/.vimrc&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.nginx语法高亮插件nginx.vim&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mkdir -pv  ~/.vim/syntax&#xA;cd ~/.vim/syntax&#xA;wget -O nginx.vim  http://www.vim.org/scripts/download_script.php?src_id=19394&#xA;echo &amp;#34;au BufRead,BufNewFile /etc/nginx/*,/usr/local/nginx/conf/* if &amp;amp;ft == &amp;#39;&amp;#39; | setfiletype nginx | endif &amp;#34; &amp;gt;&amp;gt; ~/.vim/filetype.vim&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
        </item></channel>
</rss>
