<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Django on cAlm的个人Blog</title>
        <link>http://localhost:1313/tags/django/</link>
        <description>Recent content in Django on cAlm的个人Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 28 Sep 2018 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/django/index.xml" rel="self" type="application/rss+xml" /><item>
            <title>Django sso server(一个用户友好的的单点登录系统)</title>
            <link>http://localhost:1313/posts/2018/09/2018-09-28-django-sso-server%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E5%8F%8B%E5%A5%BD%E7%9A%84%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F/</link>
            <pubDate>Fri, 28 Sep 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/09/2018-09-28-django-sso-server%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E5%8F%8B%E5%A5%BD%E7%9A%84%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F/</guid>
            <description>&lt;p&gt;最近写了一个单点登录系统,这里做一些总结.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/wp-content/uploads/2018/09/5C45207A-AF09-475D-ACD6-E732CFE1596D.png&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;&lt;img src=&#34;images/5C45207A-AF09-475D-ACD6-E732CFE1596D.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/a&gt; github地址:(欢迎来star一发^_^) &lt;a class=&#34;link&#34; href=&#34;https://github.com/calmkart/Django-sso-server&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/calmkart/Django-sso-server&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;1流程原理&#34;&gt;1.流程原理&#xA;&lt;/h3&gt;&lt;h4 id=&#34;1系统管理流程&#34;&gt;&amp;lt;1&amp;gt;.系统管理流程&#xA;&lt;/h4&gt;&lt;p&gt;管理员在初始化系统时，填写ldap相关设置以及管理员账号相关设置，之后管理员账号可以在管理员后台调整相关配置 其中: a.系统初始化时将自动生成rsa公私钥,系统中所有涉及的密码,都会经过aes加密存放在数据库中,包括rsa私钥也会经过aes加密存放 b.在取用密码时将调用aes解密,加密的salt写在了common/crypto.py中,也可以自己替换&lt;/p&gt;&#xA;&lt;h4 id=&#34;2用户流程&#34;&gt;&amp;lt;2&amp;gt;.用户流程&#xA;&lt;/h4&gt;&lt;p&gt;用户登录sso系统，验证ldap账号成功后，将用户信息以&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;now = time.time()&#xA;user_info = &amp;#34;{0}|||||{1}&amp;#34;.format(ldap_username, now)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;的形式,通过rsa公钥加密写入cookie中，key为sso_user&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;response.set_cookie(&amp;#39;sso_user&amp;#39;, rsa.crypto(&#xA;                public_key, user_info), domain=options.objects.all()[0].cookie_domain)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他需要接入sso系统的子系统可以通过sso系统的api，来判断用户是否可以登录&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;url:      /api/auth&#xA;method:   POST&#xA;post_json_data:  {&amp;#34;sso_user&amp;#34;:cookie}&#xA;return:     {&amp;#34;status&amp;#34;:True/False, &amp;#34;msg&amp;#34;:username}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本sso系统已提供了相关装饰器，可在管理后台-添加站点的帮助栏查看&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import requests&#xA;&#xA;def auth_login(func):&#xA;&amp;#39;&amp;#39;&amp;#39;&#xA;装饰器,用于需要登录的views functions,将读取cookie并调用sso的api获取username&#xA;&#xA;也可手动编写相关装饰器&#xA;sso系统的登录鉴权api为&amp;#34;http://sso域名/api/auth&amp;#34;(如&amp;#34;http://sso.calmkart.com/api/auth&amp;#34;)&#xA;用POST方法以json形式将sso_cookie传给上述api,&#xA;返回{&amp;#34;status&amp;#34;:True, &amp;#34;msg&amp;#34;:{username}}则登录成功&#xA;否则{&amp;#34;status&amp;#34;:False, &amp;#34;msg&amp;#34;:{exception}}则登录失败&#xA;&#xA;&amp;#39;&amp;#39;&amp;#39;&#xA;    def _auth(request):&#xA;        cookie = request.COOKIES.get(&amp;#34;sso_user&amp;#34;, &amp;#34;&amp;#34;)&#xA;        if cookie==&amp;#34;&amp;#34;:&#xA;            return HttpResponseRedirect(&amp;#34;{http://sso站域名/}&amp;#34;)&#xA;        r = request.post(&amp;#34;{http://sso站域名/api/auth}&amp;#34;,data={&amp;#34;sso_cookie&amp;#34;:cookie})&#xA;        if r.json()[&amp;#34;status&amp;#34;]==False:&#xA;            return HttpResponseRedirect(&amp;#34;{http://sso站域名}&amp;#34;)&#xA;        else:&#xA;            username = r.json()[&amp;#34;msg&amp;#34;]&#xA;            if username == &amp;#34;&amp;#34; or username == &amp;#34;error&amp;#34;:&#xA;                return HttpResponseRedirect(&amp;#34;{http://sso站域名/}&amp;#34;)&#xA;            else:&#xA;                return func(request, username)&#xA;    return _auth&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用户拥有cookie后登陆系统，系统将解cookie，并获取当前时间，若时间不超过最大时间，则返回username&lt;/p&gt;&#xA;&lt;h4 id=&#34;3企业扫码登陆流程&#34;&gt;&amp;lt;3&amp;gt;.企业扫码登陆流程&#xA;&lt;/h4&gt;&lt;p&gt;在管理后台配置企业微信扫码登陆相关参数，通过企业微信相关js api，生成二维码，用户扫码后，企业微信后台将用户请求重定向到/api/wxlogin  (method:get)上，并加上携带有用户username信息的code参数，成功则写cookie。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;h3 id=&#34;2common相关模块原理&#34;&gt;2.common相关模块原理&#xA;&lt;/h3&gt;&lt;p&gt;参见本blog其他博文&lt;/p&gt;&#xA;&lt;h4 id=&#34;1关于django的图片验证码&#34;&gt;&amp;lt;1&amp;gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=332&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;关于django的图片验证码&lt;/a&gt;&#xA;&lt;/h4&gt;&lt;h4 id=&#34;2关于python操作ldap&#34;&gt;&amp;lt;2&amp;gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=355&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;关于python操作ldap&lt;/a&gt;&#xA;&lt;/h4&gt;&lt;h4 id=&#34;3关于python操作rsaaes加解密&#34;&gt;&amp;lt;3&amp;gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/?p=353&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;关于python操作rsa,aes加解密&lt;/a&gt;&#xA;&lt;/h4&gt;</description>
        </item><item>
            <title>django生成图片验证码</title>
            <link>http://localhost:1313/posts/2018/09/2018-09-18-django%E7%94%9F%E6%88%90%E7%99%BB%E5%BD%95%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/</link>
            <pubDate>Tue, 18 Sep 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/09/2018-09-18-django%E7%94%9F%E6%88%90%E7%99%BB%E5%BD%95%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/</guid>
            <description>&lt;p&gt;最近在做一个好玩的通用django单点登录系统，登录系统少不了验证码，参考了一下别人的做法和开源项目，总结一下。&lt;/p&gt;&#xA;&lt;p&gt;结果如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;images/%e4%bc%81%e4%b8%9a%e5%be%ae%e4%bf%a1%e6%88%aa%e5%9b%be_837b19bb-98df-4c26-afae-6678c91ff47a.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;主要思路流程是，后端根据随机码绘图，然后做混淆(我这里几乎没做模糊之类的混淆)，最后将随机验证码写进后端session里，前端获取图像后，提交时与session里的验证码做比较。流程还是比较简单的，大致代码如下。&lt;/p&gt;&#xA;&lt;p&gt;1.captcha_handle.py&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;captcha_handle.py&#xA;#用于生成随机字符串以及生成验证码图片&#xA;&#xA;# -*- coding:utf-8 -*-&#xA;import random,string&#xA;from PIL import Image,ImageDraw,ImageFont,ImageFilter&#xA;&#xA;#生成随机字符串&#xA;def _getRandomChar():&#xA;    #string模块包含各种字符串，以下为小写字母加数字&#xA;    ran = string.ascii_lowercase+string.digits&#xA;    char = &amp;#39;&amp;#39;&#xA;    for i in range(4):&#xA;        char += random.choice(ran)&#xA;    return char&#xA;&#xA;#返回一个随机的RGB颜色&#xA;def _getRandomColor():&#xA;    return (random.randint(50,150),random.randint(50,150),random.randint(50,150))&#xA;&#xA;def create_captcha():&#xA;&#xA;    #创建图片，模式，大小，背景色&#xA;    img = Image.new(&amp;#39;RGB&amp;#39;, (120,30), (255,255,255))&#xA;    #创建画布&#xA;    draw = ImageDraw.Draw(img)&#xA;    #设置字体&#xA;    font = ImageFont.truetype(&amp;#39;Arial.ttf&amp;#39;, 25)&#xA;&#xA;    code = _getRandomChar()&#xA;    #将生成的字符画在画布上&#xA;    for t in range(4):&#xA;        draw.text((30*t+5,0),code[t],_getRandomColor(),font)&#xA;&#xA;    #生成干扰点&#xA;    for _ in range(random.randint(0,50)):&#xA;        #位置，颜色&#xA;        draw.point((random.randint(0, 120), random.randint(0, 30)),fill=_getRandomColor())&#xA;&#xA;    #使用模糊滤镜使图片模糊&#xA;    # img = img.filter(ImageFilter.BLUR)&#xA;    #保存&#xA;    #img.save(&amp;#39;&amp;#39;.join(code)+&amp;#39;.jpg&amp;#39;,&amp;#39;jpeg&amp;#39;)&#xA;    return img,code&#xA;&#xA;if __name__ == &amp;#39;__main__&amp;#39;:&#xA;    create_code()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.views.py&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;views.py&#xA;#视图，生成验证码图片和code，返回图片，code存进session&#xA;class get_captcha(View):&#xA;&#xA;    def get(self, request):&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        生成验证码图片和验证码code,返回验证码图片,并以形式将验证码存放在session里&#xA;        &amp;#39;&amp;#39;&amp;#39;&#xA;        try:&#xA;            f = BytesIO()&#xA;            img, code = create_captcha()&#xA;            request.session[&amp;#34;captcha&amp;#34;] = code&#xA;            img.save(f,&amp;#39;PNG&amp;#39;)&#xA;            return HttpResponse(f.getvalue())&#xA;        except Exception as e:&#xA;            log().error(str(e))&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.login.html&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{# html #}&#xA;&amp;lt;div class=&amp;#34;col-xs-4&amp;#34;&amp;gt;&#xA;    &amp;lt;img id=&amp;#34;captcha_img&amp;#34; src=&amp;#34;{% url &amp;#39;get_captcha&amp;#39; %}&amp;#34; onclick=&amp;#34;refresh_captcha()&amp;#34; style=&amp;#34;margin-top: 28px;&amp;#34;&amp;gt;&#xA;    &amp;lt;p class=&amp;#34;help-block&amp;#34; onclick=&amp;#34;refresh_captcha()&amp;#34;&amp;gt;&#xA;    看不清楚?换一张!&#xA;    &amp;lt;/p&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&#xA;{# js #}&#xA;&amp;lt;script&amp;gt;&#xA;    //刷新验证码&#xA;    function refresh_captcha() {&#xA;        $(&amp;#34;#captcha_img&amp;#34;).attr(&amp;#34;src&amp;#34;,$(&amp;#34;#captcha_img&amp;#34;)[0].src + &amp;#39;?&amp;#39;);&#xA;    };&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.url.py&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;url(r&amp;#39;^get_captcha/$&amp;#39;,cas_views.get_captcha.as_view(), name=&amp;#34;get_captcha&amp;#34;),&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.views.py&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#校验验证码是否正确&#xA;if request.session[&amp;#34;captcha&amp;#34;].lower() != captcha.lower():&#xA;    return JsonResponse({&amp;#34;status&amp;#34;:False, &amp;#34;msg&amp;#34;:&amp;#34;验证码错误!&amp;#34;})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一些代码是参考网络上其他开源代码，不过其实也挺简单的，熟悉request.session就差不多了。做个记录。&lt;/p&gt;</description>
        </item><item>
            <title>django类视图装饰器</title>
            <link>http://localhost:1313/posts/2018/09/2018-09-18-django%E7%B1%BB%E8%A7%86%E5%9B%BE%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
            <pubDate>Tue, 18 Sep 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/09/2018-09-18-django%E7%B1%BB%E8%A7%86%E5%9B%BE%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
            <description>&lt;p&gt;一点关于django类视图装饰器的小笔记。&lt;/p&gt;&#xA;&lt;p&gt;django类视图是很常用的，对于传统的函数视图来说，装饰器可以直接装饰函数，但类视图，装饰器无法直接装饰类方法。&lt;/p&gt;&#xA;&lt;p&gt;比较了几种常见的解决方法,个人觉得比较优雅的解决方法如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from django.shortcuts import render&#xA;from django.utils.decorators import method_decorator&#xA;from django.views.decorators.csrf import csrf_exempt&#xA;from django.views.generic import View&#xA;&#xA;@method_decorator(csrf_exempt, name=&amp;#34;dispatch&amp;#34;)&#xA;class login(View):&#xA;&#xA;    @method_decorator(auth_login)&#xA;    def get(self, request, username):&#xA;        #....func...&#xA;        return render(request, &amp;#39;login.html&amp;#39;, {&amp;#34;displayName&amp;#34;:username, &amp;#34;admin_flag&amp;#34;:admin_flag})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;既如以上代码，将装饰器函数传给method_decorator方法，直接修饰视图类方法。&lt;/p&gt;&#xA;&lt;p&gt;也可直接修饰视图类，对于需要修饰的方法，用name参数的形式传入method_decorator中即可，但感觉不够优雅。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from django.shortcuts import render&#xA;from django.utils.decorators import method_decorator&#xA;from django.views.decorators.csrf import csrf_exempt&#xA;from django.views.generic import View&#xA;&#xA;@method_decorator(csrf_exempt, name=&amp;#34;dispatch&amp;#34;)&#xA;@method_decorator(auth_login, name=&amp;#34;get&amp;#34;)&#xA;class login(View):&#xA;&#xA;    def get(self, request, username):&#xA;        #....func...&#xA;        return render(request, &amp;#39;login.html&amp;#39;, {&amp;#34;displayName&amp;#34;:username, &amp;#34;admin_flag&amp;#34;:admin_flag})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要稍微注意的是，csrf_exempt跨站排除装饰器，只能修饰在类视图的dispatch方法上，既原始写法如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class login(View):&#xA;    &#xA;    @method_decorator(csrf_exempt)&#xA;    def dispatch(self, request, *args, **kwargs):&#xA;        return super(login,self).dispatch(request,*args,**kwargs)&#xA;    &#xA;    def get(self, request, username):&#xA;        #....func...&#xA;        return render(request, &amp;#39;login.html&amp;#39;, {&amp;#34;displayName&amp;#34;:username, &amp;#34;admin_flag&amp;#34;:admin_flag})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但其实直接用类方法装饰器装饰视图类，传入参数name=dispatch就行了，不需要重写dispatch方法。&lt;/p&gt;&#xA;&lt;p&gt;既如上文。&lt;/p&gt;</description>
        </item><item>
            <title>为django-admin的userpermission添加read only(can view)权限</title>
            <link>http://localhost:1313/posts/2018/09/2018-09-06-%E4%B8%BAdjango-admin%E7%9A%84userpermission%E6%B7%BB%E5%8A%A0read-onlycan-view%E6%9D%83%E9%99%90/</link>
            <pubDate>Thu, 06 Sep 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/09/2018-09-06-%E4%B8%BAdjango-admin%E7%9A%84userpermission%E6%B7%BB%E5%8A%A0read-onlycan-view%E6%9D%83%E9%99%90/</guid>
            <description>&lt;p&gt;默认的django-admin中用户的models权限只有三个,分别是(Can change, Can add, Can delete),显然的,对于绝大部分crud工程师(^_^)而言,一眼看过去就少了些什么,没错,少了很关键的Can view权限.&lt;/p&gt;&#xA;&lt;p&gt;当然django-admin的用户权限是可以自定义的,需要改permission的meta,这里不细述,发现一个简单好用的django app,可以直接添加Can view权限,美滋滋.&lt;/p&gt;&#xA;&lt;p&gt;最终效果如下 &lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/wp-content/uploads/2018/09/B6CE8AA0-F925-4290-B2C0-E3C98ECF0C79.png&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;&lt;img src=&#34;images/B6CE8AA0-F925-4290-B2C0-E3C98ECF0C79.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;插件是: django-admin-view-permission 地址 &lt;a class=&#34;link&#34; href=&#34;https://github.com/ctxis/django-admin-view-permission&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/ctxis/django-admin-view-permission&lt;/a&gt; 使用方式及其简单&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#pip安装插件&#xA;pip install django-admin-view-permission&#xA;&#xA;#将app注册,记得一定注册在django.contrib.admin之前&#xA;INSTALLED_APPS = [&#xA;    &amp;#39;admin_view_permission&amp;#39;,&#xA;    &amp;#39;django.contrib.admin&amp;#39;,&#xA;    ...&#xA;]&#xA;&#xA;#更新数据库&#xA;python manage.py migrate&#xA;&#xA;即可&#xA;&#xA;#如需要只对一些数据库管用,可以&#xA;ADMIN_VIEW_PERMISSION_MODELS = [&#xA;    &amp;#39;auth.User&amp;#39;,&#xA;    ...&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;的确是个好东西啊,免掉了手写这种本应就有的权限.分享一下.&lt;/p&gt;</description>
        </item><item>
            <title>记一次立竿见影的性能优化</title>
            <link>http://localhost:1313/posts/2018/08/2018-08-02-%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AB%8B%E7%AB%BF%E8%A7%81%E5%BD%B1%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
            <pubDate>Thu, 02 Aug 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/08/2018-08-02-%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AB%8B%E7%AB%BF%E8%A7%81%E5%BD%B1%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
            <description>&lt;p&gt;通过一点细微代码的修改,将某系统首页载入时间缩短了10倍有余.&lt;/p&gt;&#xA;&lt;p&gt;系统首页大致这样&lt;/p&gt;&#xA;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/wp-content/uploads/2018/08/201882204014dama.png&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;&lt;img src=&#34;images/201882204014dama.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;逻辑是读取后台的所有服务列表,判断用户是否有权限,有权限则交给前端用ztree显示,并可进行部署操作,但因为服务太多,遍历服务后判断用户是否有权限后台耗时太长,用chrome查了下,后台数据处理费时2000ms,这样首页就载入的太慢了.&lt;/p&gt;&#xA;&lt;p&gt;第一步,查代码,原始代码如下:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@login_required&#xA;def services(request):&#xA;    user = request.user&#xA;    _online_apps = App.objects.filter(app_env=&amp;#39;online&amp;#39;)&#xA;    _test_apps = App.objects.filter(app_env=&amp;#39;test&amp;#39;)&#xA;    _dev_apps = App.objects.filter(app_env=&amp;#39;dev&amp;#39;)&#xA;&#xA;    online_apps = [a for a in _online_apps if user.has_perm(&amp;#39;deploy_perm&amp;#39;, a) or is_admin_by_group(user.username)]&#xA;    test_apps = [a for a in _test_apps if user.has_perm(&amp;#39;deploy_perm&amp;#39;, a) or is_admin_by_group(user.username)]&#xA;    dev_apps = [a for a in _dev_apps if user.has_perm(&amp;#39;deploy_perm&amp;#39;, a) or is_admin_by_group(user.username)]&#xA;&#xA;    online_apps_name = [{&amp;#39;name&amp;#39;:app.app_name, &amp;#39;id&amp;#39;:app.id} for app in online_apps]&#xA;    test_apps_name = [{&amp;#39;name&amp;#39;:app.app_name, &amp;#39;id&amp;#39;:app.id} for app in test_apps]&#xA;    dev_apps_name = [{&amp;#39;name&amp;#39;:app.app_name, &amp;#39;id&amp;#39;:app.id} for app in dev_apps]&#xA;    nodes = [&#xA;                {&amp;#39;name&amp;#39;:&amp;#39;online&amp;#39;,&#xA;                 &amp;#39;open&amp;#39;:&amp;#39;true&amp;#39;,&#xA;                 &amp;#39;children&amp;#39;:online_apps_name&#xA;                },&#xA;                {&amp;#39;name&amp;#39;:&amp;#39;test&amp;#39;,&#xA;                 &amp;#39;open&amp;#39;:&amp;#39;false&amp;#39;,&#xA;                 &amp;#39;children&amp;#39;:test_apps_name&#xA;                },&#xA;                {&amp;#39;name&amp;#39;:&amp;#39;dev&amp;#39;,&#xA;                 &amp;#39;open&amp;#39;:&amp;#39;false&amp;#39;,&#xA;                 &amp;#39;children&amp;#39;:dev_apps_name&#xA;                }&#xA;    ];&#xA;    return render(request, &amp;#39;services/services.html&amp;#39;, {&amp;#39;nodes&amp;#39;: json.dumps(nodes)})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也没什么复杂的,就是django models + django-guardian权限控制,然后返回数据给ztree生成树结构.&lt;/p&gt;&#xA;&lt;p&gt;初步设想是因为列表生成式太多导致速度慢,写测试代码做测试&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;python manage.py shell&#xA;&#xA;&amp;gt;&amp;gt;&amp;gt; import time&#xA;&amp;gt;&amp;gt;&amp;gt; from django.contrib.auth.models import User&#xA;&amp;gt;&amp;gt;&amp;gt; from services.views import new_service&#xA;&amp;gt;&amp;gt;&amp;gt; def test(user):&#xA;...     start = time.time()&#xA;...     new_service(user)&#xA;...     stop = time.time()&#xA;...     print stop-start&#xA;...&#xA;&amp;gt;&amp;gt;&amp;gt; pengng = User.objects.get(name=&amp;#39;pengng&amp;#39;)&#xA;&amp;gt;&amp;gt;&amp;gt; test(pengng)&#xA;1.93502497673&#xA;&amp;gt;&amp;gt;&amp;gt; test(pengng)&#xA;1.89282894135&#xA;&amp;gt;&amp;gt;&amp;gt; test(pengng)&#xA;2.14076519012&#xA;&amp;gt;&amp;gt;&amp;gt; test(pengng)&#xA;1.85515809059&#xA;&amp;gt;&amp;gt;&amp;gt; test(pengng)&#xA;1.91108703613&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发现处理时间大致在1.8-1.9s之间,然后直接将上述原始代码第一步拆了出来&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#仅测试这一步&#xA;online_apps = [a for a in _online_apps if user.has_perm(&amp;#39;deploy_perm&amp;#39;, a) or is_admin_by_group(user.username)]&#xA;&#xA;#发现时间在1.2秒左右&#xA;&amp;gt;&amp;gt;&amp;gt; test(pengng)&#xA;1.25127100945&#xA;&amp;gt;&amp;gt;&amp;gt; test(pengng)&#xA;1.27178192139&#xA;&amp;gt;&amp;gt;&amp;gt; test(pengng)&#xA;1.22848701477&#xA;&amp;gt;&amp;gt;&amp;gt; test(pengng)&#xA;1.25300002098&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;继续分拆,发现是这个user.has_perm(&amp;lsquo;deploy_perm&amp;rsquo;,a)的guardian获取权限消耗了大量的时间 然后想起这个系统里权限都是以group来赋权的,获取用户对于服务的权限要先经过组再到服务,先遍历服务再单独查看用户是否有该组权限导致重复遍历太多,其实直接获取用户对应的所有拥有权限的服务对象即可(get_objects_for_user()方法),尝试修改代码&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@login_required&#xA;def services(request):&#xA;    user = request.user&#xA;&#xA;    if is_admin_by_group(user.username):&#xA;        online_apps_name = [{&amp;#39;name&amp;#39;: a.app_name, &amp;#39;id&amp;#39;: a.id}&#xA;                            for a in App.objects.filter(app_env=&amp;#39;online&amp;#39;)]&#xA;        test_apps_name = [{&amp;#39;name&amp;#39;: a.app_name, &amp;#39;id&amp;#39;: a.id}&#xA;                          for a in App.objects.filter(app_env=&amp;#39;test&amp;#39;)]&#xA;        dev_apps_name = [{&amp;#39;name&amp;#39;: a.app_name, &amp;#39;id&amp;#39;: a.id}&#xA;                         for a in App.objects.filter(app_env=&amp;#39;dev&amp;#39;)]&#xA;    else:&#xA;        online_apps_name = [{&amp;#39;name&amp;#39;: a.app_name, &amp;#39;id&amp;#39;: a.id} for a in get_objects_for_user(&#xA;            user, &amp;#39;deploy_perm&amp;#39;, klass=App) if a.app_env == &amp;#34;online&amp;#34;]&#xA;        test_apps_name = [{&amp;#39;name&amp;#39;: a.app_name, &amp;#39;id&amp;#39;: a.id} for a in get_objects_for_user(&#xA;            user, &amp;#39;deploy_perm&amp;#39;, klass=App) if a.app_env == &amp;#34;test&amp;#34;]&#xA;        dev_apps_name = [{&amp;#39;name&amp;#39;: a.app_name, &amp;#39;id&amp;#39;: a.id} for a in get_objects_for_user(&#xA;            user, &amp;#39;deploy_perm&amp;#39;, klass=App) if a.app_env == &amp;#34;dev&amp;#34;]&#xA;&#xA;    nodes = [&#xA;        {&amp;#39;name&amp;#39;: &amp;#39;online&amp;#39;,&#xA;                 &amp;#39;open&amp;#39;: &amp;#39;true&amp;#39;,&#xA;                 &amp;#39;children&amp;#39;: online_apps_name&#xA;         },&#xA;        {&amp;#39;name&amp;#39;: &amp;#39;test&amp;#39;,&#xA;                 &amp;#39;open&amp;#39;: &amp;#39;false&amp;#39;,&#xA;                 &amp;#39;children&amp;#39;: test_apps_name&#xA;         },&#xA;        {&amp;#39;name&amp;#39;: &amp;#39;dev&amp;#39;,&#xA;                 &amp;#39;open&amp;#39;: &amp;#39;false&amp;#39;,&#xA;                 &amp;#39;children&amp;#39;: dev_apps_name&#xA;         }&#xA;    ]&#xA;    return render(request, &amp;#39;services/services.html&amp;#39;, {&amp;#39;nodes&amp;#39;: json.dumps(nodes)})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后重载文件&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; reload(services.views)&#xA;&amp;lt;module &amp;#39;services.views&amp;#39; from &amp;#39;/home/**/***/services/views.py&amp;#39;&amp;gt;&#xA;&amp;gt;&amp;gt;&amp;gt; test(pengng)&#xA;0.0817279815674&#xA;&amp;gt;&amp;gt;&amp;gt; test(pengng)&#xA;0.0788700580597&#xA;&amp;gt;&amp;gt;&amp;gt; test(pengng)&#xA;0.0756318569183&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;立竿见影,瞬间从2秒降低到了0.08秒左右 &lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/wp-content/uploads/2018/08/%e4%bc%81%e4%b8%9a%e5%be%ae%e4%bf%a1%e6%88%aa%e5%9b%be_008058b2-bd81-4a9c-8442-63afc75ac870.png&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;&lt;img src=&#34;images/%e4%bc%81%e4%b8%9a%e5%be%ae%e4%bf%a1%e6%88%aa%e5%9b%be_008058b2-bd81-4a9c-8442-63afc75ac870.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/a&gt;收工&lt;/p&gt;</description>
        </item><item>
            <title>saltshaker--一个salt的webui</title>
            <link>http://localhost:1313/posts/2018/07/2018-07-06-saltshaker-%E4%B8%80%E4%B8%AAsalt%E7%9A%84webui/</link>
            <pubDate>Fri, 06 Jul 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/07/2018-07-06-saltshaker-%E4%B8%80%E4%B8%AAsalt%E7%9A%84webui/</guid>
            <description>&lt;p&gt;salt的webui,官方的是halite,但已经被放弃了，不维护很久了 尝试过其他几个star比较的开源实现,比如saltpad,但要么就是bug满天飞,要么就是技能栈不符难以二次开发 最后发现了一个开源实现叫saltshaker的不错,最终效果如下 &lt;a class=&#34;link&#34; href=&#34;http://www.calmkart.com/wp-content/uploads/2018/07/%e4%bc%81%e4%b8%9a%e5%be%ae%e4%bf%a1%e6%88%aa%e5%9b%be_82481f1c-b153-4fb5-928f-2b98163e9635.png&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;&lt;img src=&#34;images/%e4%bc%81%e4%b8%9a%e5%be%ae%e4%bf%a1%e6%88%aa%e5%9b%be_82481f1c-b153-4fb5-928f-2b98163e9635.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;官方项目地址 &lt;a class=&#34;link&#34; href=&#34;https://github.com/yueyongyue/saltshaker&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/yueyongyue/saltshaker&lt;/a&gt; 部署文档见 install.txt&lt;/p&gt;&#xA;&lt;p&gt;大致总结过程如下,非详情.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git clone https://github.com/yueyongyue/saltshaker.git&#xA;pip install virtualenv&#xA;virtualenv env&#xA;source env/bin/activate&#xA;yum install salt-api.noarch&#xA;&#xA;salt-api --version&#xA;pip install cherrypy==3.8.0&#xA;useradd -M -s /sbin/nologin admin&#xA;passwd admin&#xA;vim /etc/salt/master.d/saltapi.conf&#xA;systemctl restart salt-master.service&#xA;systemctl restart salt-api.service&#xA;systemctl status salt-api.service&#xA;systemctl status salt-master.service&#xA;lsof -i:50075&#xA;pip install Django==1.8.4&#xA;pip install django-crontab&#xA;&#xA;yum install python-devel.x86_64&#xA;yum install mysql-devel&#xA;yum install MySQL-python&#xA;yum install gcc&#xA;&#xA;pip install mysql-python&#xA;&#xA;查源码，改dashboard/views里index函数checkport的端口&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;几个容易踩坑的地方:&lt;/p&gt;&#xA;&lt;p&gt;1.centos7.4用pip安装mysql-python的时候，需要先安装python-devel,mysql-devel,MySQL-python,gcc,否则会报错&lt;/p&gt;&#xA;&lt;p&gt;2.supervisor要自己装，相关配置自己写一下，也容易&lt;/p&gt;&#xA;&lt;p&gt;3.如果salt-api等几个部件没有运行在默认端口，那么启动saltshaker后在首页会显示down的状态，需要修改dashboard/views.py里的index函数checkport里的端口号.&lt;/p&gt;&#xA;&lt;p&gt;4.如果salt-master版本比较高(大于2015.x)，官方yum源的salt-api就没有与之对应的版本了，需要自己下载salt-api的新包，我是自建的yum源，然后&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;createrepo &amp;lt;path&amp;gt;&#xA;createrepo --update &amp;lt;path&amp;gt; &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更新仓库信息，安装最新的包&lt;/p&gt;&#xA;&lt;p&gt;5.django crontab在settings.py里被注释掉了3个，得把注释去掉，然后把所有django crontab跑起来.&lt;/p&gt;&#xA;&lt;p&gt;最后，这个东西感觉也不是很完善好用，不过是django的，二次开发也很容易，有机会再自己来改改。&lt;/p&gt;</description>
        </item><item>
            <title>gunicorn中一个同步任务的坑</title>
            <link>http://localhost:1313/posts/2018/06/2018-06-15-gunicorn%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%9D%91/</link>
            <pubDate>Fri, 15 Jun 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/06/2018-06-15-gunicorn%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%9D%91/</guid>
            <description>&lt;p&gt;最近有些django定时任务要跑，又懒的做异步celery worker tasks了，就是普通的同步任务，用的django crontab，其中django用的是gunicorn-&amp;gt;nginx的部署方式。但几天下来，发现任务总是执行到一半就停了，排错发现一个偶尔会出现的坑&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;&amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;检测到用curl请求接口，每到31秒就停止，后续同步任务不再继续&lt;/p&gt;&#xA;&lt;p&gt;检查gonicorn参数，发现默认的timeout值为30s，既客户端请求30s后超时&lt;/p&gt;&#xA;&lt;p&gt;gunicorn启动参数加上     -t 120&lt;/p&gt;&#xA;&lt;p&gt;问题解决&lt;/p&gt;&#xA;&lt;p&gt;&amp;hellip;&lt;/p&gt;</description>
        </item><item>
            <title>关于supervisor/gosuv等控制django/flask进程的小贴士</title>
            <link>http://localhost:1313/posts/2018/02/2018-02-11-%E5%85%B3%E4%BA%8Esupervisor-gosuv%E7%AD%89%E6%8E%A7%E5%88%B6django-flask%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B0%8F%E8%B4%B4%E5%A3%AB/</link>
            <pubDate>Sun, 11 Feb 2018 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2018/02/2018-02-11-%E5%85%B3%E4%BA%8Esupervisor-gosuv%E7%AD%89%E6%8E%A7%E5%88%B6django-flask%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B0%8F%E8%B4%B4%E5%A3%AB/</guid>
            <description>&lt;p&gt;在使用supervisor/gosuv等进程控制程序控制django/flask进程时，常常会出现一个&amp;quot;BUG&amp;quot;&amp;mdash;&amp;mdash;输入supervisor restart {app}/gosuv stop/start {app}后，经常会出现django/flask重启失败，因为端口已占用的错误。&lt;/p&gt;&#xA;&lt;p&gt;这里我们常常想到，先把端口关掉不就可以了？经常在代码中加入如下命令：(如果程序是django或者flask，占用的端口是82端口)&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import subprocess&#xA;import os&#xA;&#xA;pid = os.popen(&amp;#34;lsof -i:82|grep python|awk &amp;#39;{print $2}&amp;#39;&amp;#34;).read()&#xA;if len(pid):&#xA;    subprocess.check_output(&amp;#34;kill -9 &amp;#34;+str(int(pid)), shell=True)&#xA;#注意，这里一定要用subprocess库来kill进程。用os.system运行kill -9或os.kill()都会导致新进程产生&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样虽然可行，但是比较麻烦。其实占用端口的原因是flask/django服务器自动reload造成的，只需要在supervisor/gosuv的启动指令里，加上&amp;ndash;noreload参数就不会产生这个&amp;quot;BUG&amp;quot;了，举例如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#原来启动指令&#xA;python manage.py runserver 0.0.0.0:82&#xA;#更新启动指令&#xA;python manage.py runserver 0.0.0.0:82 --noreload&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;搞定&lt;/p&gt;&#xA;</description>
        </item><item>
            <title>django使用middleware实现views的访问限制</title>
            <link>http://localhost:1313/posts/2017/12/2017-12-27-django%E4%BD%BF%E7%94%A8middleware%E5%AE%9E%E7%8E%B0views%E7%9A%84%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6/</link>
            <pubDate>Wed, 27 Dec 2017 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2017/12/2017-12-27-django%E4%BD%BF%E7%94%A8middleware%E5%AE%9E%E7%8E%B0views%E7%9A%84%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6/</guid>
            <description>&lt;p&gt;需要实现这样的需求，对于以个django app，需要对其中的一些restful api做IP访问限制，这样实现起来最方便的是在middleware中写逻辑。&lt;/p&gt;&#xA;&lt;p&gt;关于django中间件的说明： &lt;a class=&#34;link&#34; href=&#34;http://usyiyi.cn/translate/Django_111/topics/http/middleware.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;http://usyiyi.cn/translate/Django_111/topics/http/middleware.html&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/translate/django_182/topics/http/middleware.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;http://python.usyiyi.cn/translate/django_182/topics/http/middleware.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;在django app得middleware.py中添加如下代码&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from django.http import HttpResponse&#xA;&#xA;class checkIPMiddleware(object):&#xA;    def process_request(self, request):&#xA;        root_func = request.path.split(&amp;#34;/&amp;#34;)[1]&#xA;        api_flag = True if root_func==&amp;#34;api&amp;#34; else False&#xA;        if api_flag:&#xA;            ip = request.META.get(&amp;#34;HTTP_X_REAL_IP&amp;#34;, request.META.get(&amp;#34;REMOTE_ADDR&amp;#34;))&#xA;            if (ip==&amp;#34;10.10.10.10&amp;#34; or ip==&amp;#34;11.11.11.11&amp;#34;):&#xA;                return None&#xA;            else:&#xA;                return HttpReponse(&amp;#34;you are not allowed&amp;#34;)&#xA;        return None&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于request对象内容，详情如下(本代码限制的是所有/api/后的访问)： &lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/translate/django_182/ref/request-response.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;http://python.usyiyi.cn/translate/django_182/ref/request-response.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;关于获取用户IP，在没有反向代理的情况下可以获取http头中的REMOTE_ADDR字段，用request.META对象来获取 当有Nginx等反向代理的时候，就会获取到本机IP，所以需要在nginx反向代理时，将用户原IP记录下来写入HTTP头中 既配置nginx配置如下(/site-enable/default):&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;location .... {    &#xA;    proxy_set_header X-Real-IP $remote_addr;&#xA;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#xA;    proxy_set_header Host $http_host;&#xA;    proxy_set_header X-NginX-Proxy true;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后在settings.py中将这个class添加进去&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MIDDLEWARE_CLASSES = [&#xA;        &amp;#39;appname.middleware.checkIPMiddleware&amp;#39;&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重启django之后，则/api后的restful api只允许10.10.10.10和11.11.11.11访问，其他时候就会返回&amp;quot;you are not allowed&amp;quot;&lt;/p&gt;</description>
        </item></channel>
</rss>
