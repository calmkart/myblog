<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Golang on cAlm的个人Blog</title>
        <link>http://localhost:1313/tags/golang/</link>
        <description>Recent content in Golang on cAlm的个人Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Mon, 21 Oct 2019 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/golang/index.xml" rel="self" type="application/rss+xml" /><item>
            <title>使用kubectl-debug来调试pod</title>
            <link>http://localhost:1313/posts/2019/10/2019-10-21-%E4%BD%BF%E7%94%A8kubectl-debug%E6%9D%A5%E8%B0%83%E8%AF%95pod/</link>
            <pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2019/10/2019-10-21-%E4%BD%BF%E7%94%A8kubectl-debug%E6%9D%A5%E8%B0%83%E8%AF%95pod/</guid>
            <description>&lt;p&gt;在k8s环境中,我们经常会碰到各种疑难杂症.比如下面这个例子: 某pod无法启动,查看日志显示原来是init时容器无法拉取某个外部网络上的包.我们exec登陆容器后试图调试下产生这个问题的原因,我们输入ping xxx.xxx.xxx,但sh直接提示&amp;quot;找不到ping命令&amp;quot;,甚至直接无法exec到一个没有sh的容器中. 这样的情况我们该怎么办呢？这里有一个解决类似问题的调试工具&lt;a class=&#34;link&#34; href=&#34;https://github.com/aylei/kubectl-debug&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;kubectl-debug&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;kubectl-debug的原理也很简单,因为docker容器是基于namespace做的隔离,所以可以创建一个新的预装好了各种调试工具的容器,直接加入待调试容器的namespace中,这样就可以与待调试pod共享各类栈,实现方便调试.(有点类似于k8s中的sidecar设计模式,但是使用的是一个用后既销的独立容器)&lt;/p&gt;&#xA;&lt;p&gt;这里介绍一下简单的使用方式 我们可以直接下载编译好的二进制文件包 &lt;a class=&#34;link&#34; href=&#34;https://github.com/aylei/kubectl-debug/releases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/aylei/kubectl-debug/releases&lt;/a&gt; 也可以clone源代码自己做编译(可以获得更多最新修复和更新)&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 这里要开启docker,因为是通过docker编译的&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/aylei/kubectl-debug.git&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; kubectl-debug&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最简单的使用方式&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl-debug POD_NAME&lt;span class=&#34;err&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;kubectl-debug将拉取nicolaka/netshoot镜像作为默认的debug镜像. 过一小会拉取镜像的功夫,我们创建好了一个插入待调试pod namespace中的调试容器,并且已经获取了stdin和stdout,我们就可以进行调试了. 调试完成后exit退出,kubectl-debug将完成相关的清理工作.&lt;/p&gt;&#xA;&lt;p&gt;当然,如果觉得默认的nicolaka/netshoot调试镜像不好用,也可以使用自己的私有镜像进行调试&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 使用私有仓库镜像,并设置私有仓库使用的kubernetes secret&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# secret data原文请设置为 {Username: , Password: }&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 默认secret_name为kubectl-debug-registry-secret,默认namspace为default&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl-debug POD_NAME --image calmkart/netshoot:latest --registry-secret-name  --registry-secret-namespace &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;甚至如果原pod已经无法启动了,我们可以使用fork模式fork出一个新的待调试pod用于调试(自动替换掉entry-point)&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl debug POD_NAME --fork&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;更多功能可以参考&lt;a class=&#34;link&#34; href=&#34;https://github.com/aylei/kubectl-debug/blob/master/docs/zh-cn.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;kubectl-debug官方文档&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;总之这个工具还是非常实用的,我也参与添加了一些增强功能和bug修复.k8s官方据说也将在未来版本增加&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/enhancements/issues/277&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;临时容器&lt;/a&gt;功能以支持调试,虽然不知道啥时候能用上,但还是期待的.&lt;/p&gt;&#xA;&lt;div class=&#34;archived-comments&#34;&gt;&#xA;&lt;h2&gt;历史评论 (2 条)&lt;/h2&gt;&#xA;&lt;p class=&#34;comment-notice&#34;&gt;以下评论来自原 WordPress 站点，仅作存档展示。&lt;/p&gt;&#xA;&lt;div class=&#34;comment-item&#34;&gt;&#xA;&lt;div class=&#34;comment-meta&#34;&gt;&lt;strong&gt;myway&lt;/strong&gt; (2019-10-23 16:59)&lt;/div&gt;&#xA;&lt;div class=&#34;comment-body&#34;&gt;请问下如何调试生产环境的k8s呢，用kubectl-debug会不会有什么风险？&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;comment-item comment-reply&#34;&gt;&#xA;&lt;div class=&#34;comment-meta&#34;&gt;&lt;strong&gt;calmkart&lt;/strong&gt; (2019-10-24 20:12)&lt;/div&gt;&#xA;&lt;div class=&#34;comment-body&#34;&gt;你只要不乱搞，看不出有啥风险。 乱搞,ex: 1.乱给forkpod打label 2.在debug container里一顿神操作 之类.&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;</description>
        </item><item>
            <title>helm chart的制作及使用(顺便拉个票)</title>
            <link>http://localhost:1313/posts/2019/08/2019-08-14-helm-chart%E7%9A%84%E5%88%B6%E4%BD%9C%E5%8F%8A%E4%BD%BF%E7%94%A8%E9%A1%BA%E4%BE%BF%E6%8B%89%E4%B8%AA%E7%A5%A8/</link>
            <pubDate>Wed, 14 Aug 2019 00:00:00 +0000</pubDate>
            <guid>http://localhost:1313/posts/2019/08/2019-08-14-helm-chart%E7%9A%84%E5%88%B6%E4%BD%9C%E5%8F%8A%E4%BD%BF%E7%94%A8%E9%A1%BA%E4%BE%BF%E6%8B%89%E4%B8%AA%E7%A5%A8/</guid>
            <description>&lt;p&gt;首先拉个票 [阿里云开发者社区-云原生应用大赛] &lt;a class=&#34;link&#34; href=&#34;https://developer.aliyun.com/hub&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://developer.aliyun.com/hub&lt;/a&gt; 麻烦不反感拉票的,有兴趣有空的,给我提交的下面三个应用点个星星，多谢了。(阿里云普通账号即可投票,支付宝登录亦可) &lt;img src=&#34;images/C0B4B70807593CFFFD06C612FCE18009.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;在k8s的容器云环境中,应用的部署方式通常是编写对应的api对象申明文件来完成. 比如比较简单的应用,如简单的django应用,我们通常就需要首先编写deployment用于控制replicaset-&amp;gt;pod，然后编写service控制deployment，最后编写ingress做服务暴露. 而比较复杂的应用,如prometheus,我们通常就要用到用户定义api对象crd,然后编写对应的循环和控制,最后完成上面的那一套部署方式.&lt;/p&gt;&#xA;&lt;p&gt;显然,这挺复杂的,而且特别多的东西感觉都可以用模板传变量来代替.那么我们是否需要自己编写一个系统用以根据参数自动生成这些复杂的yaml文件呢?答案基本上是没必要的(当然一切特殊情况还是需要),我们有helm来帮我们做这一切.&lt;/p&gt;&#xA;&lt;p&gt;你可以将helm与k8s的关系看作yum之于centos的关系.helm将应用进行打包,我们就可以通过填写必要的参数，自动生成和部署批量的yaml文件，从而实现一键部署复杂的系统. 比如promethues在k8s中的部署,如果我们用编写Yaml的方法来部署,很可能就要编写数十个yaml文件(包括promethues,alertmanager,grafana,push-gateway等等),但我们如果使用helm，我们就只需要一行命令&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install stable/prometheus-operator&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么，我们应该怎样才能制作helm中的chart软件包用于给用户自动安装呢?首先,我们需要安装helm,下载二进制文件即可. &lt;a class=&#34;link&#34; href=&#34;https://github.com/helm/helm/releases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/helm/helm/releases&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;然后我们开始创建一个helm软件包(project-name可替换)&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm create &amp;lt;project-name&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以看到，创建了如下文件夹 &lt;img src=&#34;images/%e4%bc%81%e4%b8%9a%e5%be%ae%e4%bf%a1%e6%88%aa%e5%9b%be_86ed0736-bdd6-4486-83a6-a6dedf0d876d.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;其中template下就是各个yaml文件的模板,而values.yaml则是可以填充进各个yaml文件模板的参数(用户可调节). 我们要做的就是对values.yaml和template下各模板做修改,以适应实际应用的需求.&lt;/p&gt;&#xA;&lt;p&gt;其中,template的模板语法用的是golang的template语法，再加上sprig模板库函数(&lt;a class=&#34;link&#34; href=&#34;https://github.com/Masterminds/sprig&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;https://github.com/Masterminds/sprig&lt;/a&gt;)&lt;/p&gt;&#xA;&lt;p&gt;当我们设计好了一个chart之后,我们可以通过如下命令测试生成的yaml文件是否符合预期&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install  --dry-run --debug ../&amp;lt;project-name&amp;gt;                                                &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以通过-f values.yaml统一设置参数,也可以通过&amp;ndash;set 单一设置参数&lt;/p&gt;&#xA;&lt;p&gt;如果符合预期,我们就可以直接安装了&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install  ../&amp;lt;project-name&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;更多的helm相关的资料可以参考 &lt;a class=&#34;link&#34; href=&#34;https://whmzsu.github.io/helm-doc-zh-cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;&#xA;    &gt;helm用户与开发者指南(中文版)&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;archived-comments&#34;&gt;&#xA;&lt;h2&gt;历史评论 (4 条)&lt;/h2&gt;&#xA;&lt;p class=&#34;comment-notice&#34;&gt;以下评论来自原 WordPress 站点，仅作存档展示。&lt;/p&gt;&#xA;&lt;div class=&#34;comment-item&#34;&gt;&#xA;&lt;div class=&#34;comment-meta&#34;&gt;&lt;strong&gt;huangguohuan&lt;/strong&gt; (2019-08-15 14:29)&lt;/div&gt;&#xA;&lt;div class=&#34;comment-body&#34;&gt;向dalao低头，投了&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;comment-item comment-reply&#34;&gt;&#xA;&lt;div class=&#34;comment-meta&#34;&gt;&lt;strong&gt;calmkart&lt;/strong&gt; (2019-08-15 19:11)&lt;/div&gt;&#xA;&lt;div class=&#34;comment-body&#34;&gt;多谢安全王&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;comment-item&#34;&gt;&#xA;&lt;div class=&#34;comment-meta&#34;&gt;&lt;strong&gt;liuhuohua&lt;/strong&gt; (2019-08-16 11:15)&lt;/div&gt;&#xA;&lt;div class=&#34;comment-body&#34;&gt;喜欢看博主的技术文章，票已投&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;comment-item comment-reply&#34;&gt;&#xA;&lt;div class=&#34;comment-meta&#34;&gt;&lt;strong&gt;calmkart&lt;/strong&gt; (2019-08-20 13:36)&lt;/div&gt;&#xA;&lt;div class=&#34;comment-body&#34;&gt;谢谢&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;</description>
        </item></channel>
</rss>
